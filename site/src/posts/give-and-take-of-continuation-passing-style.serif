import * from "../elements.serif" hiding {body};
import {code-block, —} from "../components.serif";
import datetime from "../datetime.serif";

export default {
  id: 95,
  slug: "give-and-take-of-continuation-passing-style",
  title: ["The ", code "give", " and ", code "take", " of continuation-passing style"],
  datetime: datetime "2020-10-08" "10:41:26" "Europe/Berlin",
  tags: ["continuation-passing-style", "javascript", "programming"],
  body: body,
};

body = [

  p [
   "I have been experimenting with ",
    a "https://en.wikipedia.org/wiki/Continuation-passing_style"
      "continuation-passing style", " recently. Writing code in this
    style feels strange but exciting! I recently discovered that one
    can use functions in place of objects.",
  ],

  p [
   "Local mutation and reassignment are acceptable, but I avoid them
    whenever practical. As a result I use ", code "reduce", " ",
    em "a lot", ".",
  ],

  code-block "javascript" `
    //    reduce :: (b -> a -> b) -> b -> Array a -> b
    const reduce = f => b => as => as.reduce ((b, a) => f (b) (a), b);

    //    append :: a -> Array a -> Array a
    const append = a => as => [...as, a];

    //    blah :: Integer -> String -> { id :: Integer, name :: String }
    const blah = id => name => ({id, name});

    > reduce (({id, blahs}) => name => ({id: id + 1, blahs: append (blah (id) (name)) (blahs)}))
    .        ({id: 1, blahs: []})
    .        (['foo', 'bar', 'baz'])
    . .blahs
    [{id: 1, name: 'foo'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]
  `,

  p [
   "☝️ This has been my approach for the past several years. The accumulator
    contains all necessary state, and at the end of the reduction I access
    whichever fields are relevant (in this case just ", code "blahs", ").",
  ],

  code-block "javascript" `
    > reduce (cont => name => id => append (blah (id) (name)) (cont (id + 1)))
    .        (id => [])
    .        (['foo', 'bar', 'baz'])
    .        (1)
    [{id: 3, name: 'foo'}, {id: 2, name: 'bar'}, {id: 1, name: 'baz'}]
  `,

  p [
   "☝️ This was my first attempt at using continuations. The problem is
    that function wrapping happens from left to right, so the ", code "id", "
    is threaded from right to left, giving the wrong result.",
  ],

  code-block "javascript" `
    > reduce (cont => name => id => blahs => cont (id + 1) (append (blah (id) (name)) (blahs)))
    .        (id => blahs => blahs)
    .        (['foo', 'bar', 'baz'])
    .        (1)
    .        ([])
    [{id: 1, name: 'baz'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]
  `,

  p [
   "☝️ This was my second attempt. The order is reversed, but the ",
    code "id", " and ", code "name", " values are still mismatched.",
  ],

  p [
   "I needed more control. What if the initial accumulator were ",
    code "give => give (1) ([])", "? In the base case, this would mean using ",
    code "(give => give (1) ([])) (id => blahs => blahs)", " to get ",
    code "[]", ", the empty list of blahs. What is the type of ",
    code "give => give (1) ([])", "? I will refer to this function as ",
    code "take", ".",
  ],

  code-block "javascript" `
    //    take :: (Integer -> Array String -> a) -> a
    const take = give => give (1) ([]);
  `,

  p [
    code "a", " is a type variable. We have no idea what ", code "give", ",
    the continuation provided to ", code "take", ", will return. ",
    code "take", " returns whatever give returns, though, so the return
    type of ", code "take", " matches the return type of ", code "give", ".",
  ],

  p [
   "Having established that the type of the accumulator is ",
    code "(Integer -> Array String -> a) -> a", ", we need to
    have the reducing function return a function of that type.",
  ],

  code-block "javascript" `
    > reduce (take => name => give => give (1) ([blah (1) (name)]))
    .        (give => give (1) ([]))
    .        (['foo', 'bar', 'baz'])
    .        (id => blahs => blahs)
    [{id: 1, name: 'baz'}]
  `,

  p [
   "☝️ The answer is wrong", —, "we lost ", code "'foo'", " and ",
    code "'bar'", ", and ", code "'baz'", " has the wrong ", code "id", —,
   "but the types align.",
  ],

  code-block "javascript" `
    > reduce (take => name => take (id => blahs => give => give (id + 1) (append (blah (id) (name)) (blahs))))
    .        (give => give (1) ([]))
    .        (['foo', 'bar', 'baz'])
    .        (id => blahs => blahs)
    [{id: 1, name: 'foo'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]
  `,

  p [
   "☝️ Success! We receive a continuation we refer to as ", code "take", ".
    We apply ", code "take", " to gain access to ", code "id", " and ",
    code "blahs", ", and we then return a new continuation, ",
    code "give => give (id + 1) (append (blah (id) (name)) (blahs))", ",
    which is the ", code "take", " function for the next iteration.",
  ],

  p [
   "This approach extends to an arbitrary number of state variables
    (e.g. ", code "give => give (0) ('') ([]) ({})", "). I find the
    names ", code "give", " and ", code "take", " helpful for
    remembering which continuation is which. :)",
  ],

];
