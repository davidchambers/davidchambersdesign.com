import S from "sanctuary";

export {
  canonicalize-children

  text
  excerpt

  a
  a'
  article
  article'
  aside
  aside'
  b
  blockquote
  blockquote'
  body
  body'
  code
  code'
  dd
  dd'
  del
  del'
  div
  dl
  dl'
  dt
  dt'
  em
  em'
  embed
  footer
  footer'
  h1
  h1'
  h2
  h2'
  h3
  h3'
  h4
  h4'
  h5
  h5'
  h6
  h6'
  head
  head'
  header
  header'
  hr
  hr'
  html
  html'
  i
  i'
  img
  ins
  ins'
  li
  li'
  linearGradient
  link
  mask
  meta
  nav
  nav'
  object
  ol
  ol'
  p
  p'
  param
  path
  pre
  pre'
  rect
  script
  span
  stop
  strong
  strong'
  svg
  time
  title
  title'
  ul
  ul'
  var
  var'
  video
};

escape = {
  S.pipe [s => s.replaceAll("&", "&amp;"),
          s => s.replaceAll("<", "&lt;"),
          s => s.replaceAll(">", "&gt;")]
};

text value = {
  text: [value],
  render: indent => level => inline => escape value,
};

canonicalize-children children = {
  {if Array.isArray children then children else [children]}.map(child => {
    if typeof child == "string" then {
      text child.replace(new RegExp("^[ ]+", "gm"), " ").replaceAll("\n", "")
    } else {
      child
    }
  })
};

render-block-element tag-name attrs children indent level inline = {
  `${
    indent.repeat(level)
  }<${
    Symbol.keyFor tag-name
  }${
    S.foldMap String
              {entry => ` ${entry[0]}="${escape {String entry[1]}.replace(new RegExp("\n[ ]*", "g"), " ")}"`}
              {Object.entries attrs}
  }>\n${
    S.foldMap String
              {child => child.render indent {level + 1} false}
              children
  }${
    indent.repeat(level)
  }</${
    Symbol.keyFor tag-name
  }>\n`
};

render-inline-element tag-name attrs children indent level inline = {
  `${
    indent.repeat(level)
  }<${
    Symbol.keyFor tag-name
  }${
    S.foldMap String
              {entry => ` ${entry[0]}="${escape {String entry[1]}.replace(new RegExp("\n[ ]*", "g"), " ")}"`}
              {Object.entries attrs}
  }>${
    S.foldMap String
              {child => child.render indent 0 true}
              children
  }</${
    Symbol.keyFor tag-name
  }>${
    if inline then "" else "\n"
  }`
};

render-self-closing-element tag-name attrs indent level inline = {
  `${
    indent.repeat(level)
  }<${
    Symbol.keyFor tag-name
  }${
    S.foldMap String
              {entry => ` ${entry[0]}="${escape {String entry[1]}.replace(new RegExp("\n[ ]*", "g"), " ")}"`}
              {Object.entries attrs}
  } />${
    if inline then "" else "\n"
  }`
};

block-element tag-name attrs children = {
  children' = canonicalize-children children;
  {
    format: :block,
    text: children'.flatMap(child => child.text),
    render: render-block-element tag-name attrs children',
  }
};

inline-element tag-name attrs children = {
  children' = canonicalize-children children;
  format = if children'.some(node => node.format === :block) then :block else :inline;
  {
    format: format,
    text: children'.flatMap(child => child.text),
    render: indent => level => inline => {
      render = if format === :inline then render-inline-element else render-block-element;
      render tag-name attrs children' indent level inline
    },
  }
};

self-closing-element tag-name attrs = {
  format: :inline,
  text: [],
  render: render-self-closing-element tag-name attrs,
};

excerpt children = {
  children' = canonicalize-children children;
  render indent level inline = {
    S.foldMap String
              {child => child.render indent level inline}
              children'
  };
  {
    text: children.flatMap(child => child.text),
    render: render,
  }
};

;; 4.1 The document element
html' = block-element :html;
html = html' {};

;; 4.2 Document metadata
head' = block-element :head;
head = head' {};
title' = inline-element :title;
title = title' {};
base = self-closing-element :base;
link = self-closing-element :link;
meta = self-closing-element :meta;
style' = block-element :style;

;; 4.3 Sections
body' = block-element :body;
body = body' {};
article' = block-element :article;
article = article' {};
section' = block-element :section;
nav' = block-element :nav;
nav = nav' {};
aside' = inline-element :aside;
aside = aside' {};
h1' = inline-element :h1;
h1 = h1' {};
h2' = inline-element :h2;
h2 = h2' {};
h3' = inline-element :h3;
h3 = h3' {};
h4' = inline-element :h4;
h4 = h4' {};
h5' = inline-element :h5;
h5 = h5' {};
h6' = inline-element :h6;
h6 = h6' {};
hgroup' = block-element :hgroup;
header' = block-element :header;
header = header' {};
footer' = block-element :footer;
footer = footer' {};
address' = block-element :address;

;; 4.4 Grouping content
p' = inline-element :p;
p = p' {};
hr' = self-closing-element :hr;
hr = hr' {};
pre' = inline-element :pre;
pre = pre' {};
blockquote' = block-element :blockquote;
blockquote = blockquote' {};
ol' = block-element :ol;
ol = ol' {};
ul' = block-element :ul;
ul = ul' {};
menu' = block-element :menu;
li' = inline-element :li;
li = li' {};
dl' = block-element :dl;
dl = dl' {};
dt' = inline-element :dt;
dt = dt' {};
dd' = inline-element :dd;
dd = dd' {};
figure' = block-element :figure;
figcaption' = block-element :figcaption;
main' = block-element :main;
div = block-element :div;

b                        = inline-element :b {};
mask                     = block-element :mask;
rect                     = self-closing-element :rect;
;; The opening and closing tags of each of the following elements
;; are always rendered on their own lines.
linearGradient           = block-element :linearGradient;
object                   = block-element :object;
svg                      = block-element :svg;
;; The opening and closing tags of each of the following elements
;; are rendered inline unless the element contains an element
;; whose opening and closing tags are rendered on their own lines.
a'                      = inline-element :a;
a href                  = a' {href: href};
code'                   = inline-element :code;
code                    = inline-element :code {};
del'                    = inline-element :del;
del                     = inline-element :del {};
em'                     = inline-element :em;
em                      = inline-element :em {};
i'                      = inline-element :i;
i                       = inline-element :i {};
ins'                    = inline-element :ins;
ins                     = inline-element :ins {};
script                  = inline-element :script;
span                    = inline-element :span;
strong'                 = inline-element :strong;
strong                  = inline-element :strong {};
time                    = inline-element :time;
var'                    = inline-element :var;
var                     = inline-element :var {};
video                   = inline-element :video;
;; The following self-closing elements are always rendered inline.
embed                   = self-closing-element :embed;
img                     = self-closing-element :img;
param                   = self-closing-element :param;
path                    = self-closing-element :path;
stop                    = self-closing-element :stop;
