import {p, a, code, em} from "../elements.js";
import {code$002Dblock, $2014} from "../components.js";
import datetime from "../datetime.js";
const body = [p(["I have been experimenting with ", a({
  href: "https://en.wikipedia.org/wiki/Continuation-passing_style"
})(["continuation-passing style"]), " recently. Writing code in ", "this style feels strange but exciting! I recently discovered ", "that one can use functions in place of objects."]), p(["Local mutation and reassignment are acceptable, but I avoid them ", "whenever practical. As a result I use ", code(["reduce"]), " ", em(["a lot"]), "."]), code$002Dblock("javascript")("//    reduce :: (b -> a -> b) -> b -> Array a -> b\nconst reduce = f => b => as => as.reduce ((b, a) => f (b) (a), b);\n\n//    append :: a -> Array a -> Array a\nconst append = a => as => [...as, a];\n\n//    blah :: Integer -> String -> { id :: Integer, name :: String }\nconst blah = id => name => ({id, name});\n\n> reduce (({id, blahs}) => name => ({id: id + 1, blahs: append (blah (id) (name)) (blahs)}))\n.        ({id: 1, blahs: []})\n.        (['foo', 'bar', 'baz'])\n. .blahs\n[{id: 1, name: 'foo'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]\n  "), p(["☝️ This has been my approach for the past several years. ", "The accumulator contains all necessary state, and at the ", "end of the reduction I access whichever fields are relevant ", "(in this case just ", code(["blahs"]), ")."]), code$002Dblock("javascript")("> reduce (cont => name => id => append (blah (id) (name)) (cont (id + 1)))\n.        (id => [])\n.        (['foo', 'bar', 'baz'])\n.        (1)\n[{id: 3, name: 'foo'}, {id: 2, name: 'bar'}, {id: 1, name: 'baz'}]\n  "), p(["☝️ This was my first attempt at using continuations. ", "The problem is that function wrapping happens from left ", "to right, so the ", code(["id"]), " is threaded from right ", "to left, giving the wrong result."]), code$002Dblock("javascript")("> reduce (cont => name => id => blahs => cont (id + 1) (append (blah (id) (name)) (blahs)))\n.        (id => blahs => blahs)\n.        (['foo', 'bar', 'baz'])\n.        (1)\n.        ([])\n[{id: 1, name: 'baz'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]\n  "), p(["☝️ This was my second attempt. The order is reversed, but the ", code(["id"]), " and ", code(["name"]), " values are still mismatched."]), p(["I needed more control. What if the initial accumulator were ", code(["give => give (1) ([])"]), "? In the base case, this would mean ", "using ", code(["(give => give (1) ([])) (id => blahs => blahs)"]), " ", "to get ", code(["[]"]), ", the empty list of blahs. What is the type of ", code(["give => give (1) ([])"]), "? I will refer to this function as ", code(["take"]), "."]), code$002Dblock("javascript")("//    take :: (Integer -> Array String -> a) -> a\nconst take = give => give (1) ([]);\n  "), p([code(["a"]), " is a type variable. We have no idea what ", code(["give"]), ", the continuation provided to ", code(["take"]), ", ", "will return. ", code(["take"]), " returns whatever give returns, ", "though, so the return type of ", code(["take"]), " matches the ", "return type of ", code(["give"]), "."]), p(["Having established that the type of the accumulator is ", code(["(Integer -> Array String -> a) -> a"]), ", we need to ", "have the reducing function return a function of that type."]), code$002Dblock("javascript")("> reduce (take => name => give => give (1) ([blah (1) (name)]))\n.        (give => give (1) ([]))\n.        (['foo', 'bar', 'baz'])\n.        (id => blahs => blahs)\n[{id: 1, name: 'baz'}]\n  "), p(["☝️ The answer is wrong", $2014, "we lost ", code(["'foo'"]), " and ", code(["'bar'"]), ", and ", code(["'baz'"]), " has the wrong ", code(["id"]), $2014, "but the types align."]), code$002Dblock("javascript")("> reduce (take => name => take (id => blahs => give => give (id + 1) (append (blah (id) (name)) (blahs))))\n.        (give => give (1) ([]))\n.        (['foo', 'bar', 'baz'])\n.        (id => blahs => blahs)\n[{id: 1, name: 'foo'}, {id: 2, name: 'bar'}, {id: 3, name: 'baz'}]\n  "), p(["☝️ Success! We receive a continuation we refer to as ", code(["take"]), ". ", "We apply ", code(["take"]), " to gain access to ", code(["id"]), " and ", code(["blahs"]), ", and we then return a new continuation, ", code(["give => give (id + 1) (append (blah (id) (name)) (blahs))"]), ", ", "which is the ", code(["take"]), " function for the next iteration."]), p(["This approach extends to an arbitrary number of state variables ", "(e.g. ", code(["give => give (0) ('') ([]) ({})"]), "). I find the ", "names ", code(["give"]), " and ", code(["take"]), " helpful for ", "remembering which continuation is which. :)"])];
export default {
  id: 95,
  slug: "give-and-take-of-continuation-passing-style",
  title: ["The ", code(["give"]), " and ", code(["take"]), " ", "of continuation-passing style"],
  datetime: datetime("2020-10-08 10:41:26 (Europe/Berlin)"),
  tags: ["continuation-passing-style", "javascript", "programming"],
  body
};
