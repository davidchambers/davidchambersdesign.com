import {h3, p, a, code, em, strong} from "../elements.js";
import {code$002Dblock, $2014} from "../components.js";
import datetime from "../datetime.js";
const excerpt = [p(["Earlier I wrote some code which repeatedly calls a function ", "which performs a database query â€“ often ", strong(["the same"]), " ", "query. This encouraged me to explore various ways to cache the ", "results of function calls in both Python (to solve my immediate ", "problem) and JavaScript (because I find that language endlessly ", "fascinating)."]), p(["I played around with ", a({
  href: "http://en.wikipedia.org/wiki/Fibonacci_number"
})(["Fibonacci"]), ", ", "which is a well suited to the task: it can be described in just ", "a couple of lines of code yet benefits enormously from caching ", "due to its recursive nature."]), h3(["JavaScript Fibonacci without caching"]), code$002Dblock("javascript")("function fibonacci(n) {\n    if (n <= 1) return n;\n    return fibonacci(n - 2) + fibonacci(n - 1);\n}\n  ")];
const body = [...excerpt, p(["I created a simple timer:"]), code$002Dblock("javascript")("function timer(func) {\n    var i = 10, start;\n    while (i--) {\n        start = new Date;\n        func.apply(this, [].slice.call(arguments, 1));\n        console.log(func.name, 'executed in', new Date - start, 'ms');\n    }\n}\n  "), p(["How does the vanilla function perform?"]), code$002Dblock("TK")(">>> timer(fibonacci, 35);\nfibonacci executed in 559 ms\nfibonacci executed in 559 ms\nfibonacci executed in 559 ms\nfibonacci executed in 557 ms\nfibonacci executed in 557 ms\nfibonacci executed in 559 ms\nfibonacci executed in 558 ms\nfibonacci executed in 558 ms\nfibonacci executed in 559 ms\nfibonacci executed in 559 ms\n  "), p(["Values of ", code(["n"]), " much larger than 35 locked up my browser. ", "That's not good. Fortunately, it's easy to improve the performance ", "significantly."]), h3(["JavaScript Fibonacci with caching via closure"]), p(["JavaScript has closure, which means that each function has access to ", "the variables and parameters or its outer function (and the variables ", "and parameters of its outer function's outer function, and so on)."]), p(["This is incredibly powerful. It makes it possible to create a variable, ", code(["cache"]), ", which can ", em(["only"]), " be accessed by our ", code(["fibonacci"]), " function. This ensures that our cache cannot be ", "overwritten, accidentally or otherwise."]), code$002Dblock("javascript")("fibonacci = (function () {\n\n    var cache = {};\n\n    return function (n) {\n\n        var cached = cache[n];\n        if (cached) return cached;\n\n        if (n <= 1) return n;\n\n        return (cache[n] = fibonacci(n - 2) + fibonacci(n - 1));\n    };\n}());\n  "), p(["Does caching make a difference?"]), code$002Dblock("TK")(">>> timer(fibonacci, 35);\n executed in 1 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n executed in 0 ms\n  "), p(["Undeniably, yes. Not only is the new version of the function much ", "faster, but its less recursive nature makes it possible to find ", "Fibonacci numbers for much larger values of ", code(["n"]), "."]), p(["A slightly different approach is to initialize the cache with values ", "for 0 and 1, making the ", code(["if (n <= 1)"]), " logic unnecessary. ", "Since one of the cached values is now 0, however, the ", code(["if (cached)"]), " statement is no longer appropriate."]), code$002Dblock("javascript")("fibonacci = (function () {\n\n    var cache = { 0:0, 1:1 };\n\n    return function (n) {\n\n        var cached = cache[n];\n        if (typeof cached !== 'undefined') return cached;\n\n        return (cache[n] = fibonacci(n - 2) + fibonacci(n - 1));\n    };\n}());\n  "), h3(["JavaScript Fibonacci with caching via function property"]), p(["It's also possible to cache results without using closure. ", "This is important since Python (which I'll get to shortly) ", "does not have this capability."]), code$002Dblock("javascript")("function fibonacci(n) {\n\n    if (!fibonacci.cache) fibonacci.cache = {};\n\n    var cached = fibonacci.cache[n];\n    if (cached) return cached;\n\n    if (n <= 1) return n;\n\n    return (fibonacci.cache[n] = fibonacci(n - 2) + fibonacci(n - 1));\n}\n  "), p(["To avoid the overhead of checking for the existence of the cache ", "on each invocation, the cache could be initialized outside of the ", "function definition."]), code$002Dblock("javascript")("function fibonacci(n) {\n    // function body\n}\nfibonacci.cache = {};\n  "), p(["Caching via function property and caching via closure performed ", "equally well for me in Safari on Mac OS X."]), h3(["Python Fibonacci without caching"]), code$002Dblock("python")("def fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n - 2) + fibonacci(n - 1)\n  "), p(["Does the vanilla Python function outperform the vanilla JavaScript ", "function?"]), code$002Dblock("TK")(">>> import time\n>>> for i in range(10): t = time.time(); fibonacci(35); print time.time() - t;\n  "), p(["Interestingly, Python was more than an order of magnitude slower than ", "JavaScript in this worst-case scenario. The point of this exercise is ", "not to compare apples to oranges, however, it's to see how much of a ", "difference caching makes in each case."]), h3(["Python Fibonacci with caching via function property"]), code$002Dblock("python")("def fibonacci(n):\n    if n in fibonacci.cache:\n        return fibonacci.cache[n]\n    elif n <= 1:\n        return n\n    else:\n        f = fibonacci.cache[n] = fibonacci(n - 2) + fibonacci(n - 1)\n        return f\n\nfibonacci.cache = {}\n  "), p(["This resulted in ", code(["fibonacci(35)"]), " being executed roughly ", "75,000 times as fast on an empty cache as the vanilla function."]), h3(["Python Fibonacci with caching via mutable default argument"]), p(["For the sake of completion I'll include this unappealing approach."]), code$002Dblock("python")("def fibonacci(n, _cache={}):\n    if n <= 1:\n        return n\n    elif n in _cache:\n        return _cache[n]\n    else:\n        f = _cache[n] = fibonacci(n - 2) + fibonacci(n - 1)\n        return f\n  "), p(["How does this work? In Python, default arguments are brought to ", "life upon a function's creation, not its execution. Thus when ", code(["fibonacci"]), " is called with just one argument (", code(["n"]), ") ", "the value of ", code(["_cache"]), " is the dictionary that was created ", "at the time that ", code(["fibonacci"]), " was created. Python's ", "dictionaries are mutable, meaning that they can be changed in place. ", "Together, these two features make it possible to use a mutable ", "default argument", $2014, "in this case a dictionary", $2014, "as a cache."]), h3(["Final thoughts"]), p(["I had fun experimenting with these various approaches, furthering ", "my understanding of both JavaScript and Python in the process. ", "I've been writing JavaScript casually for several years; now that ", "I'm making an effort to actually ", em(["learn"]), " the language ", "I'm starting to appreciate its brilliance."])];
export default {
  id: 67,
  slug: "self-caching-functions-in-javascript-and-python",
  title: ["Self-caching functions in JavaScript and Python"],
  datetime: datetime("2010-08-29 01:10:00 (Pacific/Auckland)"),
  tags: ["javascript", "programming", "python"],
  body
};
