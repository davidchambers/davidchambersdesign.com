import Node from "./Node.serif";

export default Prelude;

{
  ArrowFunctionExpression,
  BinaryExpression,
  CallExpression,
  CompositionExpression,
  ConditionalExpression,
  Identifier,
  LogicalExpression,
  MemberExpression,
  NullLiteral,
  NumberLiteral,
  ObjectExpression,
  Property,
  StringLiteral,
  UnaryExpression,
} = Node;

#Array                  = Identifier "Array";
#CasesNotExhaustive     = Identifier "CasesNotExhaustive";
#DivisionByZero         = Identifier "DivisionByZero";
#Math                   = Identifier "Math";
#Reflect                = Identifier "Reflect";
#Symbol                 = Identifier "Symbol";
#args                   = Identifier "args";
#constructor            = Identifier "constructor";
#f                      = Identifier "f";
#idx                    = Identifier "idx";
#lhs                    = Identifier "lhs";
#name                   = Identifier "name";
#operand                = Identifier "operand";
#rhs                    = Identifier "rhs";
#target                 = Identifier "target";
#that                   = Identifier "that";
#this                   = Identifier "this";
#type                   = Identifier "type";
#x                      = Identifier "x";
#y                      = Identifier "y";

'apply                  = StringLiteral "apply";
'binary                 = StringLiteral "binary";
'concat                 = StringLiteral "concat";
'construct              = StringLiteral "construct";
'every                  = StringLiteral "every";
'fantasy-land/chain     = StringLiteral "fantasy-land/chain";
'fantasy-land/concat    = StringLiteral "fantasy-land/concat";
'fantasy-land/filter    = StringLiteral "fantasy-land/filter";
'fantasy-land/map       = StringLiteral "fantasy-land/map";
'fantasy-land/reduce    = StringLiteral "fantasy-land/reduce";
'filter                 = StringLiteral "filter";
'flatMap                = StringLiteral "flatMap";
'floor                  = StringLiteral "floor";
'for                    = StringLiteral "for";
'isArray                = StringLiteral "isArray";
'length                 = StringLiteral "length";
'map                    = StringLiteral "map";
'match                  = StringLiteral "match";
'null                   = StringLiteral "null";
'reduce                 = StringLiteral "reduce";
'reduceRight            = StringLiteral "reduceRight";
'string                 = StringLiteral "string";
'unary                  = StringLiteral "unary";

fromEsUnaryOperator operator = {
  ArrowFunctionExpression [#operand] {
    UnaryExpression operator #operand
  }
};

fromEsBinaryOperator operator = {
  ArrowFunctionExpression [#rhs] {
    ArrowFunctionExpression [#lhs] {
      BinaryExpression operator #lhs #rhs
    }
  }
};

esUnaryOperators = [
  ;; 13.5.6 Bitwise NOT Operator
  "~",
];

esBinaryOperators = [
  ;; 13.9.1 The Left Shift Operator
  "<<",
  ;; 13.9.2 The Signed Right Shift Operator
  ">>",
  ;; 13.9.3 The Unsigned Right Shift Operator
  ">>>",
  ;; 13.12 Binary Bitwise Operators
  "&",
  "^",
  "|",
];

Prelude fromPrelude = {
  operators: ObjectExpression [
    esUnaryOperators
    | map (\op -> Property (StringLiteral op) $ fromEsUnaryOperator op)
    | ObjectExpression
    | Property 'unary,
    esBinaryOperators
    | map (\op -> Property (StringLiteral op) $ fromEsBinaryOperator op)
    | ObjectExpression
    | Property 'binary,
  ],
  _apply: {
    ArrowFunctionExpression [#name] {
      ArrowFunctionExpression [#args] {
        ArrowFunctionExpression [#target] {
          CallExpression (MemberExpression (MemberExpression #target #name) 'apply) [#target, #args]
        }
      }
    }
  },
  apply: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#args] {
        CallExpression (MemberExpression #f 'apply) [NullLiteral, #args]
      }
    }
  },
  construct: {
    ArrowFunctionExpression [#constructor] {
      ArrowFunctionExpression [#args] {
        CallExpression (MemberExpression #Reflect 'construct) [#constructor, #args]
      }
    }
  },
  instanceof: {
    ArrowFunctionExpression [#constructor] {
      ArrowFunctionExpression [#x] {
        BinaryExpression "instanceof" #x #constructor
      }
    }
  },
  typeof: {
    ArrowFunctionExpression [#x] {
      ConditionalExpression (BinaryExpression "===" #x NullLiteral) 'null (UnaryExpression "typeof" #x)
    }
  },
  match: {
    ArrowFunctionExpression [#type] {
      CallExpression (CallExpression (fromPrelude "match'") [#type]) [ArrowFunctionExpression [#x] #CasesNotExhaustive]
    }
  },
  match': {
    ArrowFunctionExpression [#type] {
      MemberExpression #type $ CallExpression (MemberExpression #Symbol 'for) ['match]
    }
  },
  id: {
    ArrowFunctionExpression [#x] {
      #x
    }
  },
  const: {
    ArrowFunctionExpression [#x] {
      ArrowFunctionExpression [#y] {
        #x
      }
    }
  },
  not: {
    ArrowFunctionExpression [#x] {
      UnaryExpression "!" #x
    }
  },
  quot: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (BinaryExpression "|" (BinaryExpression "/" #lhs #rhs) (NumberLiteral 0))
      }
    }
  },
  rem: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (BinaryExpression "%" #lhs #rhs)
      }
    }
  },
  div: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (CallExpression (MemberExpression #Math 'floor) [BinaryExpression "/" #lhs #rhs])
      }
    }
  },
  mod: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (BinaryExpression "%" (BinaryExpression "+" (BinaryExpression "%" #lhs #rhs) #rhs) #rhs)
      }
    }
  },
  ;; TODO: generalize to setoid
  equals: {
    ArrowFunctionExpression [#this] {
      ArrowFunctionExpression [#that] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#this])
          (BinaryExpression "&&"
             (CallExpression (MemberExpression #Array 'isArray) [#that])
             (BinaryExpression "&&"
                (BinaryExpression "==="
                                  (MemberExpression #this 'length)
                                  (MemberExpression #that 'length))
                (CallExpression (MemberExpression #this 'every)
                                [ArrowFunctionExpression [#x, #idx] $
                                   CallExpression (CallExpression (fromPrelude "equals") [#x]) [MemberExpression #that #idx]])))
          (BinaryExpression "===" #this #that)
      }
    }
  },
  concat: {
    ArrowFunctionExpression [#this] {
      ArrowFunctionExpression [#that] {
        ConditionalExpression
          (LogicalExpression "or"
                             (CallExpression (MemberExpression #Array 'isArray) [#this])
                             (BinaryExpression "===" (UnaryExpression "typeof" #this) 'string))
          (CallExpression (MemberExpression #this 'concat) [#that])
          (CallExpression (MemberExpression #this 'fantasy-land/concat) [#that])
      }
    }
  },
  reduce: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (
            MemberExpression #x {
              ConditionalExpression (CallExpression (MemberExpression #Array 'isArray) [#x]) 'reduce 'fantasy-land/reduce
            }
          ) [
            ArrowFunctionExpression [#y, #x] {
              CallExpression (CallExpression #f [#y]) [#x]
            },
            #y,
          ]
        }
      }
    }
  },
  ;; TODO: generalize to foldable
  reduceRight: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (MemberExpression #x 'reduceRight) [
            ArrowFunctionExpression [#y, #x] $ CallExpression (CallExpression #f [#y]) [#x],
            #y,
          ]
        }
      }
    }
  },
  filter: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#x])
          (CallExpression (MemberExpression #x 'filter) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]])
          (CallExpression (MemberExpression #x 'fantasy-land/filter) [#f])
      }
    }
  },
  reject: {
    ;; \predicate -> filter (not . predicate)
    ArrowFunctionExpression [#f] {
      CallExpression (fromPrelude "filter") [CompositionExpression (fromPrelude "not") #f]
    }
    ;; This may be possible once sectioning is supported:
    ;; filter . (not .)
    ;; CompositionExpression (fromPrelude "filter") (CompositionExpression (fromPrelude "not"))
  },
  map: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#x])
          (CallExpression (MemberExpression #x 'map) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]])
          (CallExpression (MemberExpression #x 'fantasy-land/map) [#f])
      }
    }
  },
  ;; TODO: generalize to functor
  flip: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (CallExpression #f [#x]) [#y]
        }
      }
    }
  },
  chain: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#x])
          (CallExpression (MemberExpression #x 'flatMap) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]])
          (CallExpression (MemberExpression #x 'fantasy-land/chain) [#f])
      }
    }
  },
};
