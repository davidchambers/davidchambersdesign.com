import Node from "./Node.serif";

export default Prelude;

{
  ArrowFunctionExpression,
  BinaryExpression,
  CallExpression,
  CompositionExpression,
  ConditionalExpression,
  Identifier,
  LogicalExpression,
  MemberExpression,
  StringLiteral,
  UnaryExpression,
} = Node;

isArray name = {
  CallExpression (MemberExpression (Identifier "Array")
                                   (StringLiteral "isArray"))
                 [Identifier name]
};

isString name = {
  BinaryExpression "==="
                   (UnaryExpression "typeof" $ Identifier name)
                   (StringLiteral "string")
};

Prelude fromPrelude = {
  _apply: {
    ArrowFunctionExpression [Identifier "name"] {
      ArrowFunctionExpression [Identifier "args"] {
        ArrowFunctionExpression [Identifier "target"] {
          CallExpression (MemberExpression (MemberExpression (Identifier "target") (Identifier "name")) (StringLiteral "apply"))
                         [Identifier "target", Identifier "args"]
        }
      }
    }
  },
  apply: {
    ArrowFunctionExpression [Identifier "args"] {
      ArrowFunctionExpression [Identifier "target"] {
        CallExpression (MemberExpression (Identifier "target") (StringLiteral "apply")) [Identifier "target", Identifier "args"]
      }
    }
  },
  construct: {
    ArrowFunctionExpression [Identifier "constructor"] {
      ArrowFunctionExpression [Identifier "args"] {
        CallExpression (MemberExpression (Identifier "Reflect") (StringLiteral "construct")) [Identifier "constructor", Identifier "args"]
      }
    }
  },
  match: {
    ArrowFunctionExpression [Identifier "type"] {
      CallExpression (CallExpression (fromPrelude "match'") [Identifier "type"])
                     [ArrowFunctionExpression [Identifier "_"] $ Identifier "CasesNotExhaustive"]
    }
  },
  match': {
    ArrowFunctionExpression [Identifier "type"] {
      MemberExpression (Identifier "type")
                       (CallExpression (MemberExpression (Identifier "Symbol") (StringLiteral "for")) [StringLiteral "match"])
    }
  },
  id: {
    ArrowFunctionExpression [Identifier "x"] {
      Identifier "x"
    }
  },
  const: {
    ArrowFunctionExpression [Identifier "x"] {
      ArrowFunctionExpression [Identifier "y"] {
        Identifier "x"
      }
    }
  },
  not: {
    ArrowFunctionExpression [Identifier "b"] {
      UnaryExpression "!" (Identifier "b")
    }
  },
  ;; TODO: generalize to setoid
  equals: {
    ArrowFunctionExpression [Identifier "this"] {
      ArrowFunctionExpression [Identifier "that"] {
        ConditionalExpression
          (isArray "this")
          (BinaryExpression "&&"
                            (isArray "that")
                            (BinaryExpression "&&"
                                              (BinaryExpression "==="
                                                                (MemberExpression (Identifier "this") $ StringLiteral "length")
                                                                (MemberExpression (Identifier "that") $ StringLiteral "length"))
                                              (CallExpression (MemberExpression (Identifier "this") $ StringLiteral "every")
                                                              [ArrowFunctionExpression [Identifier "x", Identifier "idx"] $
                                                                 CallExpression (CallExpression (fromPrelude "equals") [Identifier "x"])
                                                                                [MemberExpression (Identifier "that") (Identifier "idx")]])))
          (BinaryExpression "===" (Identifier "this") (Identifier "that"))
      }
    }
  },
  concat: {
    ArrowFunctionExpression [Identifier "this"] {
      ArrowFunctionExpression [Identifier "that"] {
        ConditionalExpression
          (LogicalExpression "or" (isArray "this") (isString "this"))
          (CallExpression (MemberExpression (Identifier "this") (StringLiteral "concat"))
                          [Identifier "that"])
          (CallExpression (MemberExpression (Identifier "this") (StringLiteral "fantasy-land/concat"))
                          [Identifier "that"])
      }
    }
  },
  reduce: {
    ArrowFunctionExpression [Identifier "f"] {
      ArrowFunctionExpression [Identifier "y"] {
        ArrowFunctionExpression [Identifier "foldable"] {
          CallExpression (
            MemberExpression (Identifier "foldable")
                             (ConditionalExpression (isArray "foldable")
                                                    (StringLiteral "reduce")
                                                    (StringLiteral "fantasy-land/reduce"))
          ) [
            ArrowFunctionExpression [Identifier "y", Identifier "x"] {
              CallExpression (CallExpression (Identifier "f") [Identifier "y"]) [Identifier "x"]
            },
            Identifier "y",
          ]
        }
      }
    }
  },
  ;; TODO: generalize to foldable
  reduceRight: {
    ArrowFunctionExpression [Identifier "f"] {
      ArrowFunctionExpression [Identifier "y"] {
        ArrowFunctionExpression [Identifier "foldable"] {
          CallExpression (MemberExpression (Identifier "foldable") (StringLiteral "reduceRight")) [
            ArrowFunctionExpression [Identifier "y", Identifier "x"] {
              CallExpression (CallExpression (Identifier "f") [Identifier "y"]) [Identifier "x"]
            },
            Identifier "y",
          ]
        }
      }
    }
  },
  filter: {
    ArrowFunctionExpression [Identifier "predicate"] {
      ArrowFunctionExpression [Identifier "filterable"] {
        ConditionalExpression
          (isArray "filterable")
          (CallExpression (MemberExpression (Identifier "filterable")
                                            (StringLiteral "filter"))
                          [ArrowFunctionExpression [Identifier "x"] $
                             CallExpression (Identifier "predicate")
                                            [Identifier "x"]])
          (CallExpression (MemberExpression (Identifier "filterable")
                                            (StringLiteral "fantasy-land/filter"))
                          [Identifier "predicate"])
      }
    }
  },
  reject: {
    ;; \predicate -> filter (not . predicate)
    ArrowFunctionExpression [Identifier "predicate"] {
      CallExpression (fromPrelude "filter") [CompositionExpression (fromPrelude "not") (Identifier "predicate")]
    }
    ;; This may be possible once sectioning is supported:
    ;; filter . (not .)
    ;; CompositionExpression (fromPrelude "filter") (CompositionExpression (fromPrelude "not"))
  },
  map: {
    ArrowFunctionExpression [Identifier "f"] {
      ArrowFunctionExpression [Identifier "functor"] {
        ConditionalExpression
          (isArray "functor")
          (CallExpression (MemberExpression (Identifier "functor")
                                            (StringLiteral "map"))
                          [ArrowFunctionExpression [Identifier "x"] $
                             CallExpression (Identifier "f")
                                            [Identifier "x"]])
          (CallExpression (MemberExpression (Identifier "functor")
                                            (StringLiteral "fantasy-land/map"))
                          [Identifier "f"])
      }
    }
  },
  ;; TODO: generalize to functor
  flip: {
    ArrowFunctionExpression [Identifier "f"] {
      ArrowFunctionExpression [Identifier "y"] {
        ArrowFunctionExpression [Identifier "x"] {
          CallExpression (CallExpression (Identifier "f") [Identifier "x"]) [Identifier "y"]
        }
      }
    }
  },
  chain: {
    ArrowFunctionExpression [Identifier "f"] {
      ArrowFunctionExpression [Identifier "chain"] {
        ConditionalExpression
          (isArray "chain")
          (CallExpression (MemberExpression (Identifier "chain")
                                            (StringLiteral "flatMap"))
                          [ArrowFunctionExpression [Identifier "x"] $
                             CallExpression (Identifier "f")
                                            [Identifier "x"]])
          (CallExpression (MemberExpression (Identifier "chain")
                                            (StringLiteral "fantasy-land/chain"))
                          [Identifier "f"])
      }
    }
  },
};
