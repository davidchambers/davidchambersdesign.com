import Node from "./Node.serif";

export {
  _apply,
  apply,
  construct,
  match,
  id,
  const_,
  not,
  concat,
  filter,
  reject,
  map,
  flip,
  chain,
};

{
  ArrowFunctionExpression,
  BinaryExpression,
  CallExpression,
  ConditionalExpression,
  Identifier,
  LogicalExpression,
  MemberExpression,
  StringLiteral,
  UnaryExpression,
} = Node;

isArray name = {
  CallExpression (MemberExpression (Identifier "Array")
                                   (StringLiteral "isArray"))
                 [Identifier name]
};

isString name = {
  BinaryExpression "is"
                   (UnaryExpression "typeof" $ Identifier name)
                   (StringLiteral "string")
};

_apply preludeIdent = {
  ArrowFunctionExpression [Identifier "name"] {
    ArrowFunctionExpression [Identifier "args"] {
      ArrowFunctionExpression [Identifier "target"] {
        CallExpression (MemberExpression (MemberExpression (Identifier "target")
                                                           (Identifier "name"))
                                         (StringLiteral "apply"))
                       [Identifier "target", Identifier "args"]
      }
    }
  }
};

apply preludeIdent = {
  ArrowFunctionExpression [Identifier "args"] {
    ArrowFunctionExpression [Identifier "target"] {
      CallExpression (MemberExpression (Identifier "target")
                                       (StringLiteral "apply"))
                     [Identifier "target", Identifier "args"]
    }
  }
};

construct preludeIdent = {
  ArrowFunctionExpression [Identifier "constructor"] {
    ArrowFunctionExpression [Identifier "args"] {
      CallExpression (MemberExpression (Identifier "Reflect")
                                       (StringLiteral "construct"))
                     [Identifier "constructor", Identifier "args"]
    }
  }
};

match preludeIdent = {
  ArrowFunctionExpression [Identifier "type"] {
    MemberExpression (Identifier "type")
                     (CallExpression (MemberExpression (Identifier "Symbol")
                                                       (StringLiteral "for"))
                                     [StringLiteral "match"])
  }
};

id preludeIdent = {
  ArrowFunctionExpression [Identifier "x"] {
    Identifier "x"
  }
};

;; TODO: rename
const_ preludeIdent = {
  ArrowFunctionExpression [Identifier "x"] {
    ArrowFunctionExpression [Identifier "y"] {
      Identifier "x"
    }
  }
};

not preludeIdent = {
  ArrowFunctionExpression [Identifier "b"] {
    UnaryExpression "!" (Identifier "b")
  }
};

concat preludeIdent = {
  ArrowFunctionExpression [Identifier "this"] {
    ArrowFunctionExpression [Identifier "that"] {
      ConditionalExpression
        (LogicalExpression "or" (isArray "this") (isString "this"))
        (CallExpression (MemberExpression (Identifier "this")
                                          (StringLiteral "concat"))
                        [Identifier "that"])
        (CallExpression (MemberExpression (Identifier "this")
                                          (StringLiteral "fantasy-land/concat"))
                        [Identifier "that"])
    }
  }
};

filter preludeIdent = {
  ArrowFunctionExpression [Identifier "predicate"] {
    ArrowFunctionExpression [Identifier "filterable"] {
      ConditionalExpression
        (isArray "filterable")
        (CallExpression (MemberExpression (Identifier "filterable")
                                          (StringLiteral "filter"))
                        [ArrowFunctionExpression [Identifier "x"] $
                           CallExpression (Identifier "predicate")
                                          [Identifier "x"]])
        (CallExpression (MemberExpression (Identifier "filterable")
                                          (StringLiteral "fantasy-land/filter"))
                        [Identifier "predicate"])
    }
  }
};

reject preludeIdent = {
  ArrowFunctionExpression [Identifier "predicate"] {
    CallExpression (MemberExpression preludeIdent $ StringLiteral "filter") [
      ArrowFunctionExpression [Identifier "x"] {
        UnaryExpression "!" $ CallExpression (Identifier "predicate") [Identifier "x"]
      },
    ]
  }
};

map preludeIdent = {
  ArrowFunctionExpression [Identifier "f"] {
    ArrowFunctionExpression [Identifier "functor"] {
      ConditionalExpression
        (isArray "functor")
        (CallExpression (MemberExpression (Identifier "functor")
                                          (StringLiteral "map"))
                        [ArrowFunctionExpression [Identifier "x"] $
                           CallExpression (Identifier "f")
                                          [Identifier "x"]])
        (CallExpression (MemberExpression (Identifier "functor")
                                          (StringLiteral "fantasy-land/map"))
                        [Identifier "f"])
    }
  }
};

;; TODO: generalize to functor
flip preludeIdent = {
  ArrowFunctionExpression [Identifier "f"] {
    ArrowFunctionExpression [Identifier "y"] {
      ArrowFunctionExpression [Identifier "x"] {
        CallExpression (CallExpression (Identifier "f") [Identifier "x"]) [Identifier "y"]
      }
    }
  }
};

chain preludeIdent = {
  ArrowFunctionExpression [Identifier "f"] {
    ArrowFunctionExpression [Identifier "chain"] {
      ConditionalExpression
        (isArray "chain")
        (CallExpression (MemberExpression (Identifier "chain")
                                          (StringLiteral "flatMap"))
                        [ArrowFunctionExpression [Identifier "x"] $
                           CallExpression (Identifier "f")
                                          [Identifier "x"]])
        (CallExpression (MemberExpression (Identifier "chain")
                                          (StringLiteral "fantasy-land/chain"))
                        [Identifier "f"])
    }
  }
};
