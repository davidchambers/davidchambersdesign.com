import * from "./InternalNode.serif";
import {Nothing} from "./Maybe.serif";

export default Prelude;

Function = ArrowFunctionExpression;

#$discriminant      = Identifier "$discriminant";
#DivisionByZero     = Identifier "DivisionByZero";
#chain              = Identifier "chain";
#concat             = Identifier "concat";
#constructor        = Identifier "constructor";
#count              = Identifier "count";
#equals             = Identifier "equals";
#f                  = Identifier "f";
#filter             = Identifier "filter";
#from               = Identifier "from";
#g                  = Identifier "g";
#globalThis         = Identifier "globalThis";
#id                 = Identifier "id";
#idx                = Identifier "idx";
#index              = Identifier "index";
#lhs                = Identifier "lhs";
#null               = Identifier "null";
#pattern            = Identifier "pattern";
#prefix             = Identifier "prefix";
#pure               = Identifier "pure";
#reduce             = Identifier "reduce";
#replacement        = Identifier "replacement";
#rhs                = Identifier "rhs";
#separator          = Identifier "separator";
#string             = Identifier "string";
#suffix             = Identifier "suffix";
#that               = Identifier "that";
#these              = Identifier "these";
#this               = Identifier "this";
#to                 = Identifier "to";
#typeRep            = Identifier "typeRep";
#typeof             = Identifier "typeof";
#x                  = Identifier "x";
#xs                 = Identifier "xs";
#y                  = Identifier "y";

'Array                  = String "Array";
'JSON                   = String "JSON";
'Map                    = String "Map";
'Math                   = String "Math";
'Object                 = String "Object";
'Reflect                = String "Reflect";
'Set                    = String "Set";
'call                   = String "call";
'charAt                 = String "charAt";
'charCodeAt             = String "charCodeAt";
'codePointAt            = String "codePointAt";
'concat                 = String "concat";
'construct              = String "construct";
'constructor            = String "constructor";
'endsWith               = String "endsWith";
'every                  = String "every";
'fantasy-land/ap        = String "fantasy-land/ap";
'fantasy-land/chain     = String "fantasy-land/chain";
'fantasy-land/compose   = String "fantasy-land/compose";
'fantasy-land/concat    = String "fantasy-land/concat";
'fantasy-land/empty     = String "fantasy-land/empty";
'fantasy-land/equals    = String "fantasy-land/equals";
'fantasy-land/filter    = String "fantasy-land/filter";
'fantasy-land/map       = String "fantasy-land/map";
'fantasy-land/of        = String "fantasy-land/of";
'fantasy-land/reduce    = String "fantasy-land/reduce";
'filter                 = String "filter";
'flatMap                = String "flatMap";
'floor                  = String "floor";
'function               = String "function";
'join                   = String "join";
'length                 = String "length";
'map                    = String "map";
'name                   = String "name";
'null                   = String "null";
'of                     = String "of";
'parse                  = String "parse";
'prototype              = String "prototype";
'reduce                 = String "reduce";
'reduceRight            = String "reduceRight";
'repeat                 = String "repeat";
'replace                = String "replace";
'replaceAll             = String "replaceAll";
'slice                  = String "slice";
'split                  = String "split";
'startsWith             = String "startsWith";
'toLowerCase            = String "toLowerCase";
'toString               = String "toString";
'toUpperCase            = String "toUpperCase";
'trim                   = String "trim";
'trimEnd                = String "trimEnd";
'trimStart              = String "trimStart";

construct constructor arguments = (
  Call (Member (Member #globalThis 'Reflect) 'construct) [
    constructor,
    arguments,
  ]
);

Set values  = construct (Member #globalThis 'Set) (Array [values]);
Map entries = construct (Member #globalThis 'Map) (Array [entries]);

defineSwitch discriminant transform default cases = (
  Call (
    Function [#$discriminant] (
      Block (
        (.., Return default) (
          globalThis.Object.entries cases <&> \case [
            [name, consequent] -> (
              If (Infix "===" #$discriminant $ String $ transform name) (
                Block [Return consequent]
              ) Nothing
            )
          ]
        )
      )
    )
  ) [discriminant]
);

typeSwitch identifier = (
  defineSwitch (Call (Member (Member (Member (Member #globalThis 'Object) 'prototype) 'toString) 'call) [identifier]) \tag -> "[object " + tag + "]"
);

typeRepSwitch typeRep = (
  defineSwitch (Member typeRep 'name) id
);

Prelude = {
  null:           Call (Member (Member #globalThis 'JSON) 'parse) ['null],
  complement:     Function [#rhs] $ Prefix "~" #rhs,
  instanceof:     Function [#constructor] $ Function [#x] $ Infix "instanceof" #x #constructor,
  typeof:         Function [#x] $ ConditionalExpression (Infix "===" #x #null) 'null (Prefix "typeof" #x),
  id:             Function [#x] #x,
  const:          Function [#x] $ Function [#y] #x,
  not:            Function [#x] $ Prefix "!" #x,
  negate:         Function [#x] $ Prefix "-" #x,
  quot:           Function [#lhs] $ Function [#rhs] $ Block [Return $ ConditionalExpression (Infix "===" #rhs $ Number 0) #DivisionByZero $ Infix "|" (Infix "/" #lhs #rhs) $ Number 0],
  rem:            Function [#lhs] $ Function [#rhs] $ ConditionalExpression (Infix "===" #rhs $ Number 0) #DivisionByZero $ Infix "%" #lhs #rhs,
  div:            Function [#lhs] $ Function [#rhs] $ ConditionalExpression (Infix "===" #rhs $ Number 0) #DivisionByZero $ Call (Member (Member #globalThis 'Math) 'floor) [Infix "/" #lhs #rhs],
  mod:            Function [#lhs] $ Function [#rhs] $ ConditionalExpression (Infix "===" #rhs $ Number 0) #DivisionByZero $ Infix "%" (Infix "+" (Infix "%" #lhs #rhs) #rhs) #rhs,
  charAt:         Function [#index] $ Function [#string] $ Call (Member #string 'charAt) [#index],
  charCodeAt:     Function [#index] $ Function [#string] $ Call (Member #string 'charCodeAt) [#index],
  codePointAt:    Function [#index] $ Function [#string] $ Call (Member #string 'codePointAt) [#index],
  startsWith:     Function [#prefix] $ Function [#string] $ Call (Member #string 'startsWith) [#prefix],
  endsWith:       Function [#suffix] $ Function [#string] $ Call (Member #string 'endsWith) [#suffix],
  toLower:        Function [#string] $ Call (Member #string 'toLowerCase) [],
  toUpper:        Function [#string] $ Call (Member #string 'toUpperCase) [],
  trim:           Function [#string] $ Call (Member #string 'trim) [],
  trimStart:      Function [#string] $ Call (Member #string 'trimStart) [],
  trimEnd:        Function [#string] $ Call (Member #string 'trimEnd) [],
  repeat:         Function [#count] $ Function [#string] $ Call (Member #string 'repeat) [#count],
  replace:        Function [#pattern] $ Function [#replacement] $ Function [#string] $ Call (Member #string 'replace) [#pattern, #replacement],
  replaceAll:     Function [#pattern] $ Function [#replacement] $ Function [#string] $ Call (Member #string 'replaceAll) [#pattern, #replacement],
  splitOn:        Function [#separator] $ Function [#string] $ Call (Member #string 'split) [#separator],
  joinWith:       Function [#separator] $ Function [#xs] $ Call (Member #xs 'join) [#separator],
  slice:          Function [#from] $ Function [#to] $ Function [#xs] $ Call (Member #xs 'slice) [#from, #to],
  sliceFrom:      Function [#from] $ Function [#xs] $ Call (Member #xs 'slice) [#from],
  sliceTo:        Function [#to] $ Function [#xs] $ Call (Member #xs 'slice) [Number 0, #to],
  -- TODO: generalize to setoid
  equals: (
    Function [#this] (
      Function [#that] (
        typeSwitch #this (Infix "===" #this #that) {
          Array: (
            typeSwitch #that (Boolean false) {
              Array: Infix "&&" (Infix "===" (Member #this 'length) (Member #that 'length)) (Call (Member #this 'every) [Function [#x, #idx] $ Call (Call #equals [#x]) [Member #that #idx]]),
            }
          ),
          Object: (
            typeSwitch #that (Boolean false) {
              Object: ConditionalExpression (Infix "===" (Call #typeof [Member #this 'fantasy-land/equals]) 'function)
                                            (Call (Member #this 'fantasy-land/equals) [#that])
                                            (Infix "===" #this #that),
            }
          ),
        }
      )
    )
  ),
  -- TODO: generalize to ord
  min:            Function [#x] $ Function [#y] $ ConditionalExpression (Infix "<=" #x #y) #x #y,
  -- TODO: generalize to ord
  max:            Function [#x] $ Function [#y] $ ConditionalExpression (Infix "<=" #x #y) #y #x,
  compose:        Function [#f] $ Function [#g] $ typeSwitch #g (Call (Member #g 'fantasy-land/compose) [#f]) {Function: Function [#x] $ Call #f [Call #g [#x]]},
  concat:         Function [#this] $ Function [#that] $ typeSwitch #this (Call (Member #this 'fantasy-land/concat) [#that]) {Array: Call (Member #this 'concat) [#that], String: Call (Member #this 'concat) [#that]},
  empty:          Function [#typeRep] $ typeRepSwitch #typeRep (Call (Member #typeRep 'fantasy-land/empty) []) {Array: Array [], Object: Object [], String: String "", Set: Set $ Array [], Map: Map $ Array []},
  reduce:         Function [#f] $ Function [#y] $ Function [#xs] $ typeSwitch #xs (Call (Member #xs 'fantasy-land/reduce) [Function [#y, #x] $ Call (Call #f [#y]) [#x], #y]) {Array: Call (Member #xs 'reduce) [Function [#y, #x] $ Call (Call #f [#y]) [#x], #y]},
  -- TODO: generalize to foldable
  reduceRight:    Function [#f] $ Function [#y] $ Function [#x] $ Call (Member #x 'reduceRight) [Function [#y, #x] $ Call (Call #f [#y]) [#x], #y],
  filter:         Function [#f] $ Function [#xs] $ typeSwitch #xs (Call (Member #xs 'fantasy-land/filter) [#f]) {Array: Call (Member #xs 'filter) [Function [#x] $ Call #f [#x]], Set: Set $ Call (Call #filter [#f]) [Array [Spread #xs]]},
  reject:         Function [#f] $ Call #filter [Function [#x] $ Prefix "!" $ Call #f [#x]],
  map:            Function [#f] $ Function [#xs] $ typeSwitch #xs (Call (Member #xs 'fantasy-land/map) [#f]) {Array: Call (Member #xs 'map) [Function [#x] $ Call #f [#x]]},
  -- TODO: generalize to functor
  flip:           Function [#f] $ Function [#y] $ Function [#x] $ Call (Call #f [#x]) [#y],
  pure:           Function [#typeRep] $ typeRepSwitch #typeRep (Member #typeRep 'fantasy-land/of) {Array: Member (Member #globalThis 'Array) 'of, Function: Function [#x] $ Function [#y] #x, Set: Function [#x] $ Set $ Array [#x]},
  -- TODO: generalize to apply
  ap:             Function [#lhs] $ Function [#rhs] $ typeSwitch #lhs (Call (Member #rhs 'fantasy-land/ap) [#lhs]) {Array: Call (Member #lhs 'flatMap) [Function [#f] $ Call (Member #rhs 'map) [Function [#x] $ Call #f [#x]]]},
  append:         Function [#x] $ Function [#xs] $ Call (Call #concat [#xs]) [Call (Call #pure [Member #xs 'constructor]) [#x]],
  prepend:        Function [#x] $ Function [#xs] $ Call (Call #concat [Call (Call #pure [Member #xs 'constructor]) [#x]]) [#xs],
  chain:          Function [#f] $ Function [#x] $ typeSwitch #x (Call (Member #x 'fantasy-land/chain) [#f]) {Array: Call (Member #x 'flatMap) [Function [#x] $ Call #f [#x]], Function: Function [#y] $ Call (Call #x [Call #f [#y]]) [#y]},
  join:           Call #chain [#id],
  contains:       Function [#this] $ Function [#these] $ Call (Call (Call #reduce [Function [#x] $ Function [#that] $ Infix "||" #x $ Call (Call #equals [#this]) [#that]]) [Boolean false]) [#these],
};
