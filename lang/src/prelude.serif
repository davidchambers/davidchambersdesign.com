import {Nothing, Just} from "./Maybe.serif";
import * from "./Node.serif";

export default Prelude;

compose' = flip compose;
curry2 f x y = f (x, y);

ident   = Identifier;
boolean = BooleanLiteral;
number  = NumberLiteral;
string  = StringLiteral;
array   = ArrayExpression;
object  = ObjectExpression;
spread  = SpreadElement;
member  = MemberExpression;
member' = compose' string . member;
lambda  = flip $ reduceRight $ flip $ ArrowFunctionExpression . Array.of;
apply   = reduce $ compose' Array.of . CallExpression;
invoke object names ...arguments = {
  CallExpression (reduce member' object names) arguments
};

#CasesNotExhaustive = ident "CasesNotExhaustive";
#DivisionByZero     = ident "DivisionByZero";
#args               = ident "args";
#constructor        = ident "constructor";
#f                  = ident "f";
#g                  = ident "g";
#globalThis         = ident "globalThis";
#idx                = ident "idx";
#lhs                = ident "lhs";
#rhs                = ident "rhs";
#that               = ident "that";
#these              = ident "these";
#this               = ident "this";
#type               = ident "type";
#typeRep            = ident "typeRep";
#x                  = ident "x";
#xs                 = ident "xs";
#y                  = ident "y";

_typeof_      = UnaryExpression "typeof";
_!_           = UnaryExpression "!";
_/_           = BinaryExpression "/";
_%_           = BinaryExpression "%";
_+_           = BinaryExpression "+";
_-_           = BinaryExpression "-";
_instanceof_  = BinaryExpression "instanceof";
_===_         = BinaryExpression "===";
_&_           = BinaryExpression "&";
_^_           = BinaryExpression "^";
_|_           = BinaryExpression "|";
_&&_          = LogicalExpression "&&";
_||_          = LogicalExpression "||";

construct = curry2 $ invoke #globalThis ["Reflect", "construct"];
Set = construct (member' #globalThis "Set") . array . Array.of;
Map = construct (member' #globalThis "Map") . array . Array.of;

cond predicate consequent alternative = {
  ConditionalExpression predicate consequent $ Just alternative
};

defineSwitch discriminant transform default = {
  SwitchExpression discriminant
  . append (SwitchCase [Nothing] default)
  . map (\[names, expr] -> SwitchCase (Just . string . transform <$> .split ["/"] names) expr)
  . Object.entries
};

typeSwitch identifier = {
  defineSwitch (invoke #globalThis ["Object", "prototype", "toString", "call"] identifier) \tag -> "[object " + tag + "]"
};

typeRepSwitch typeRep = {
  defineSwitch (member' typeRep "name") id
};

filter predicate xs = invoke xs ["filter"] predicate;

Prelude = {
  XOR: {
    lambda [#rhs, #lhs] {
      typeSwitch #rhs (#lhs `_^_` #rhs) {
        Set: Set $ array [
          spread $ filter (lambda [#x] $ _!_ $ invoke #rhs ["has"] #x) $ array [spread #lhs],
          spread $ filter (lambda [#x] $ _!_ $ invoke #lhs ["has"] #x) $ array [spread #rhs],
        ],
      }
    }
  },
  OR:             lambda [#rhs, #lhs] $ typeSwitch #rhs (#lhs `_|_` #rhs) {Set: Set $ array [spread #lhs, spread #rhs]},
  AND:            lambda [#rhs, #lhs] $ typeSwitch #rhs (#lhs `_&_` #rhs) {Set: Set $ filter (lambda [#x] $ invoke #rhs ["has"] #x) $ array [spread #lhs]},
  subtract:       lambda [#rhs, #lhs] $ typeSwitch #rhs (#lhs `_-_` #rhs) {Set: Set $ filter (lambda [#x] $ _!_ $ invoke #rhs ["has"] #x) $ array [spread #lhs]},
  construct:      lambda [#constructor, #args] $ construct #constructor #args,
  instanceof:     lambda [#constructor, #x] $ #x `_instanceof_` #constructor,
  typeof:         lambda [#x] $ cond (#x `_===_` NullLiteral) (string "null") (_typeof_ #x),
  match:          lambda [#type] $ apply (ident "match'") [#type, lambda [#x] #CasesNotExhaustive],
  match':         lambda [#type] $ member #type $ invoke #globalThis ["Symbol", "for"] $ string "match",
  id:             lambda [#x] #x,
  const:          lambda [#x, #y] #x,
  not:            lambda [#x] $ _!_ #x,
  quot:           lambda [#lhs, #rhs] $ cond (#rhs `_===_` number 0) #DivisionByZero (#lhs `_/_` #rhs `_|_` number 0),
  rem:            lambda [#lhs, #rhs] $ cond (#rhs `_===_` number 0) #DivisionByZero (#lhs `_%_` #rhs),
  div:            lambda [#lhs, #rhs] $ cond (#rhs `_===_` number 0) #DivisionByZero (invoke #globalThis ["Math", "floor"] $ #lhs `_/_` #rhs),
  mod:            lambda [#lhs, #rhs] $ cond (#rhs `_===_` number 0) #DivisionByZero (#lhs `_%_` #rhs `_+_` #rhs `_%_` #rhs),
  ;; TODO: generalize to setoid
  equals: {
    lambda [#this, #that] {
      typeSwitch #this (#this `_===_` #that) {
        Array: {
          typeSwitch #that (boolean false) {
            Array: (member' #this "length" `_===_` member' #that "length") `_&&_` (invoke #this ["every"] $ ArrowFunctionExpression [#x, #idx] $ apply (ident "equals") [#x, member #that #idx]),
          }
        },
      }
    }
  },
  compose:        lambda [#f, #g] $ typeSwitch #g (invoke #g ["fantasy-land/compose"] #f) {Function: lambda [#x] $ apply #f [apply #g [#x]]},
  concat:         lambda [#this, #that] $ typeSwitch #this (invoke #this ["fantasy-land/concat"] #that) {Array/String: invoke #this ["concat"] #that},
  empty:          lambda [#typeRep] $ typeRepSwitch #typeRep (invoke #typeRep ["fantasy-land/empty"] ()) {Array: array [], Object: object [], String: string "", Set: Set $ array [], Map: Map $ array []},
  reduce:         lambda [#f, #y, #xs] $ typeSwitch #xs (invoke #xs ["fantasy-land/reduce"] (#f, #y)) {Array: invoke #xs ["reduce"] (ArrowFunctionExpression [#y, #x] $ apply #f [#y, #x], #y)},
  ;; TODO: generalize to foldable
  reduceRight:    lambda [#f, #y, #x] $ invoke #x ["reduceRight"] (ArrowFunctionExpression [#y, #x] $ apply #f [#y, #x], #y),
  filter:         lambda [#f, #xs] $ typeSwitch #xs (invoke #xs ["fantasy-land/filter"] #f) {Array: filter (lambda [#x] $ apply #f [#x]) #xs},
  reject:         lambda [#f] $ apply (ident "filter") [lambda [#x] $ _!_ $ apply #f [#x]],
  map:            lambda [#f, #xs] $ typeSwitch #xs (invoke #xs ["fantasy-land/map"] #f) {Array: invoke #xs ["map"] $ lambda [#x] $ apply #f [#x]},
  ;; TODO: generalize to functor
  flip:           lambda [#f, #y, #x] $ apply #f [#x, #y],
  of:             lambda [#typeRep] $ typeRepSwitch #typeRep (member' #typeRep "fantasy-land/of") {Array: reduce member' #globalThis ["Array", "of"], Function: lambda [#x, #y] #x, Set: lambda [#x] $ Set $ array [#x]},
  append:         lambda [#x, #xs] $ apply (ident "concat") [#xs, apply (ident "of") [member' #xs "constructor", #x]],
  prepend:        lambda [#x, #xs] $ apply (ident "concat") [apply (ident "of") [member' #xs "constructor", #x], #xs],
  chain:          lambda [#f, #x] $ typeSwitch #x (invoke #x ["fantasy-land/chain"] #f) {Array: invoke #x ["flatMap"] $ lambda [#x] $ apply #f [#x], Function: lambda [#y] $ apply #x [apply #f [#y], #y]},
  join:           apply (ident "chain") [ident "id"],
  contains:       lambda [#this, #these] $ apply (ident "reduce") [lambda [#x, #that] $ #x `_||_` (apply (ident "equals") [#this, #that]), boolean false, #these],
};
