import {Nothing, Just} from "./Maybe.serif";
import * from "./Node.serif";

export default Prelude;

#CasesNotExhaustive     = Identifier "CasesNotExhaustive";
#DivisionByZero         = Identifier "DivisionByZero";
#args                   = Identifier "args";
#chain                  = Identifier "chain";
#constructor            = Identifier "constructor";
#equals                 = Identifier "equals";
#f                      = Identifier "f";
#filter                 = Identifier "filter";
#globalThis             = Identifier "globalThis";
#id                     = Identifier "id";
#idx                    = Identifier "idx";
#lhs                    = Identifier "lhs";
#match'                 = Identifier "match'";
#reduce                 = Identifier "reduce";
#rhs                    = Identifier "rhs";
#that                   = Identifier "that";
#these                  = Identifier "these";
#this                   = Identifier "this";
#type                   = Identifier "type";
#typeRep                = Identifier "typeRep";
#x                      = Identifier "x";
#y                      = Identifier "y";

#Array                  = MemberExpression #globalThis $ StringLiteral "Array";
#Math                   = MemberExpression #globalThis $ StringLiteral "Math";
#Object                 = MemberExpression #globalThis $ StringLiteral "Object";
#Reflect                = MemberExpression #globalThis $ StringLiteral "Reflect";
#Set                    = MemberExpression #globalThis $ StringLiteral "Set";
#Symbol                 = MemberExpression #globalThis $ StringLiteral "Symbol";

'Array                  = StringLiteral "Array";
'Function               = StringLiteral "Function";
'Map                    = StringLiteral "Map";
'Object                 = StringLiteral "Object";
'Set                    = StringLiteral "Set";
'String                 = StringLiteral "String";
'apply                  = StringLiteral "apply";
'concat                 = StringLiteral "concat";
'construct              = StringLiteral "construct";
'every                  = StringLiteral "every";
'fantasy-land/chain     = StringLiteral "fantasy-land/chain";
'fantasy-land/concat    = StringLiteral "fantasy-land/concat";
'fantasy-land/empty     = StringLiteral "fantasy-land/empty";
'fantasy-land/filter    = StringLiteral "fantasy-land/filter";
'fantasy-land/map       = StringLiteral "fantasy-land/map";
'fantasy-land/of        = StringLiteral "fantasy-land/of";
'fantasy-land/reduce    = StringLiteral "fantasy-land/reduce";
'filter                 = StringLiteral "filter";
'flatMap                = StringLiteral "flatMap";
'floor                  = StringLiteral "floor";
'for                    = StringLiteral "for";
'has                    = StringLiteral "has";
'isArray                = StringLiteral "isArray";
'length                 = StringLiteral "length";
'map                    = StringLiteral "map";
'match                  = StringLiteral "match";
'name                   = StringLiteral "name";
'null                   = StringLiteral "null";
'of                     = StringLiteral "of";
'prototype              = StringLiteral "prototype";
'reduce                 = StringLiteral "reduce";
'reduceRight            = StringLiteral "reduceRight";
'string                 = StringLiteral "string";
'toString               = StringLiteral "toString";

Object#toString identifier = {
  CallExpression (MemberExpression #Reflect 'apply) [
    MemberExpression (MemberExpression #Object 'prototype) 'toString,
    identifier,
    ArrayExpression [],
  ]
};

Prelude = {
  XOR: {
    ArrowFunctionExpression [#rhs] {
      ArrowFunctionExpression [#lhs] {
        SwitchExpression (Object#toString #rhs) [
          SwitchCase [Just $ StringLiteral "[object Set]"] {
            CallExpression (MemberExpression #Reflect 'construct) [
              #Set,
              ArrayExpression [
                CallExpression (MemberExpression (ArrayExpression [SpreadElement #lhs]) 'filter)
                               [ArrowFunctionExpression [#x] $ CallExpression (MemberExpression #rhs 'has) [#x]],
              ],
            ]
          },
          SwitchCase [Nothing] {
            BinaryExpression "^" #lhs #rhs
          },
        ]
      }
    }
  },
  OR: {
    ArrowFunctionExpression [#rhs] {
      ArrowFunctionExpression [#lhs] {
        SwitchExpression (Object#toString #rhs) [
          SwitchCase [Just $ StringLiteral "[object Set]"] {
            CallExpression (MemberExpression #Reflect 'construct) [
              #Set,
              ArrayExpression [ArrayExpression [SpreadElement #lhs, SpreadElement #rhs]],
            ]
          },
          SwitchCase [Nothing] {
            BinaryExpression "|" #lhs #rhs
          },
        ]
      }
    }
  },
  subtract: {
    ArrowFunctionExpression [#rhs] {
      ArrowFunctionExpression [#lhs] {
        SwitchExpression (Object#toString #rhs) [
          SwitchCase [Just $ StringLiteral "[object Set]"] {
            CallExpression (MemberExpression #Reflect 'construct) [
              #Set,
              ArrayExpression [
                CallExpression (MemberExpression (ArrayExpression [SpreadElement #lhs]) 'filter)
                               [ArrowFunctionExpression [#x] $ UnaryExpression "!" $ CallExpression (MemberExpression #rhs 'has) [#x]],
              ],
            ]
          },
          SwitchCase [Nothing] {
            BinaryExpression "-" #lhs #rhs
          },
        ]
      }
    }
  },
  apply: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#args] {
        CallExpression (MemberExpression #f 'apply) [NullLiteral, #args]
      }
    }
  },
  construct: {
    ArrowFunctionExpression [#constructor] {
      ArrowFunctionExpression [#args] {
        CallExpression (MemberExpression #Reflect 'construct) [#constructor, #args]
      }
    }
  },
  instanceof: {
    ArrowFunctionExpression [#constructor] {
      ArrowFunctionExpression [#x] {
        BinaryExpression "instanceof" #x #constructor
      }
    }
  },
  typeof: {
    ArrowFunctionExpression [#x] {
      ConditionalExpression (BinaryExpression "===" #x NullLiteral) 'null (Just $ UnaryExpression "typeof" #x)
    }
  },
  match: {
    ArrowFunctionExpression [#type] {
      CallExpression (CallExpression #match' [#type]) [ArrowFunctionExpression [#x] #CasesNotExhaustive]
    }
  },
  match': {
    ArrowFunctionExpression [#type] {
      MemberExpression #type $ CallExpression (MemberExpression #Symbol 'for) ['match]
    }
  },
  id: {
    ArrowFunctionExpression [#x] {
      #x
    }
  },
  const: {
    ArrowFunctionExpression [#x] {
      ArrowFunctionExpression [#y] {
        #x
      }
    }
  },
  not: {
    ArrowFunctionExpression [#x] {
      UnaryExpression "!" #x
    }
  },
  quot: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (Just $ BinaryExpression "|" (BinaryExpression "/" #lhs #rhs) (NumberLiteral 0))
      }
    }
  },
  rem: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (Just $ BinaryExpression "%" #lhs #rhs)
      }
    }
  },
  div: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (Just $ CallExpression (MemberExpression #Math 'floor) [BinaryExpression "/" #lhs #rhs])
      }
    }
  },
  mod: {
    ArrowFunctionExpression [#lhs] {
      ArrowFunctionExpression [#rhs] {
        ConditionalExpression (BinaryExpression "===" #rhs (NumberLiteral 0))
                              #DivisionByZero
                              (Just $ BinaryExpression "%" (BinaryExpression "+" (BinaryExpression "%" #lhs #rhs) #rhs) #rhs)
      }
    }
  },
  ;; TODO: generalize to setoid
  equals: {
    ArrowFunctionExpression [#this] {
      ArrowFunctionExpression [#that] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#this])
          (BinaryExpression "&&"
             (CallExpression (MemberExpression #Array 'isArray) [#that])
             (BinaryExpression "&&"
                (BinaryExpression "==="
                                  (MemberExpression #this 'length)
                                  (MemberExpression #that 'length))
                (CallExpression (MemberExpression #this 'every)
                                [ArrowFunctionExpression [#x, #idx] $
                                   CallExpression (CallExpression #equals [#x]) [MemberExpression #that #idx]])))
          (Just $ BinaryExpression "===" #this #that)
      }
    }
  },
  concat: {
    ArrowFunctionExpression [#this] {
      ArrowFunctionExpression [#that] {
        ConditionalExpression
          (LogicalExpression "or"
                             (CallExpression (MemberExpression #Array 'isArray) [#this])
                             (BinaryExpression "===" (UnaryExpression "typeof" #this) 'string))
          (CallExpression (MemberExpression #this 'concat) [#that])
          (Just $ CallExpression (MemberExpression #this 'fantasy-land/concat) [#that])
      }
    }
  },
  empty: {
    ArrowFunctionExpression [#typeRep] {
      SwitchExpression (MemberExpression #typeRep 'name) [
        SwitchCase [Just 'Array] {
          ArrayExpression []
        },
        SwitchCase [Just 'Object] {
          ObjectExpression []
        },
        SwitchCase [Just 'String] {
          StringLiteral ""
        },
        SwitchCase [Just 'Set, Just 'Map] {
          CallExpression (MemberExpression #Reflect 'construct) [#typeRep, ArrayExpression [ArrayExpression []]]
        },
        SwitchCase [Nothing] {
          CallExpression (MemberExpression #typeRep 'fantasy-land/empty) []
        },
      ]
    }
  },
  reduce: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (
            MemberExpression #x {
              ConditionalExpression (CallExpression (MemberExpression #Array 'isArray) [#x]) 'reduce (Just 'fantasy-land/reduce)
            }
          ) [
            ArrowFunctionExpression [#y, #x] {
              CallExpression (CallExpression #f [#y]) [#x]
            },
            #y,
          ]
        }
      }
    }
  },
  ;; TODO: generalize to foldable
  reduceRight: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (MemberExpression #x 'reduceRight) [
            ArrowFunctionExpression [#y, #x] $ CallExpression (CallExpression #f [#y]) [#x],
            #y,
          ]
        }
      }
    }
  },
  filter: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#x])
          (CallExpression (MemberExpression #x 'filter) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]])
          (Just $ CallExpression (MemberExpression #x 'fantasy-land/filter) [#f])
      }
    }
  },
  reject: {
    ;; \predicate -> filter (not . predicate)
    ArrowFunctionExpression [#f] {
      CallExpression #filter [ArrowFunctionExpression [#x] $ UnaryExpression "!" $ CallExpression #f [#x]]
    }
    ;; This may be possible once sectioning is supported:
    ;; filter . (not .)
    ;; CompositionExpression #filter (CompositionExpression #not)
  },
  map: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        ConditionalExpression
          (CallExpression (MemberExpression #Array 'isArray) [#x])
          (CallExpression (MemberExpression #x 'map) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]])
          (Just $ CallExpression (MemberExpression #x 'fantasy-land/map) [#f])
      }
    }
  },
  ;; TODO: generalize to functor
  flip: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#y] {
        ArrowFunctionExpression [#x] {
          CallExpression (CallExpression #f [#x]) [#y]
        }
      }
    }
  },
  of: {
    ArrowFunctionExpression [#typeRep] {
      SwitchExpression (MemberExpression #typeRep 'name) [
        SwitchCase [Just 'Array] {
          MemberExpression #Array 'of
        },
        SwitchCase [Just 'Function] {
          ArrowFunctionExpression [#x] $ ArrowFunctionExpression [#y] #x
        },
        SwitchCase [Just 'Set] {
          ArrowFunctionExpression [#x] {
            CallExpression (MemberExpression #Reflect 'construct) [
              #typeRep,
              ArrayExpression [ArrayExpression [#x]],
            ]
          }
        },
        SwitchCase [Nothing] {
          MemberExpression #typeRep 'fantasy-land/of
        },
      ]
    }
  },
  chain: {
    ArrowFunctionExpression [#f] {
      ArrowFunctionExpression [#x] {
        SwitchExpression (Object#toString #x) [
          SwitchCase [Just $ StringLiteral "[object Array]"] {
            CallExpression (MemberExpression #x 'flatMap) [ArrowFunctionExpression [#x] $ CallExpression #f [#x]]
          },
          SwitchCase [Just $ StringLiteral "[object Function]"] {
            ArrowFunctionExpression [#y] $ CallExpression (CallExpression #x [CallExpression #f [#y]]) [#y]
          },
          SwitchCase [Nothing] {
            CallExpression (MemberExpression #x 'fantasy-land/chain) [#f]
          },
        ]
      }
    }
  },
  join: {
    CallExpression #chain [#id]
  },
  contains: {
    ArrowFunctionExpression [#this] {
      ArrowFunctionExpression [#these] {
        CallExpression (
          CallExpression (
            CallExpression #reduce [
              ArrowFunctionExpression [#x] {
                ArrowFunctionExpression [#that] {
                  LogicalExpression "or" #x (CallExpression (CallExpression #equals [#this]) [#that])
                }
              }
            ]
          ) [BooleanLiteral false]
        ) [#these]
      }
    }
  },
};
