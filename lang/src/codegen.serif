import {maybe} from "./Maybe.serif";

export default fromNode;

-- https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = Set.new [
  -- reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  -- future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
  -- reserved in strict mode
  "arguments",
  "eval",
];

validEsIdentifierName name = (
  .test [name] $ RegExp "^[$_A-Za-z][$_A-Za-z0-9]*$"
);

fromEscapedIdentifierName name = {
  type: "Identifier",
  name,
};

escapeChar c = (
  c
  & charCodeAt 0
  & .toString [16]
  & toUpper
  & .padStart [4, "0"]
  & concat "$"
);

escape name = (
  if name == "eval" || name == "import" then name
  else if RESERVED_WORDS has name then name + "$"
  else if validEsIdentifierName name then name
  else replaceAll (RegExp ("[^$_A-Za-z0-9]", "g")) escapeChar name
);

fromMember object property = case property of [
  String value -> (
    if validEsIdentifierName value then {
      type: "MemberExpression",
      object: fromNode object,
      property: fromEscapedIdentifierName value,
      computed: false,
      optional: false,
    } else {
      type: "MemberExpression",
      object: fromNode object,
      property: fromNode property,
      computed: true,
      optional: false,
    }
  ),
  property -> {
    type: "MemberExpression",
    object: fromNode object,
    property: fromNode property,
    computed: true,
    optional: false,
  },
];

fromNode node = case node of [
  Array elements -> (
    {type: "ArrayExpression", elements: fromNode <$> elements}
  ),
  ArrowFunctionExpression parameters body:(Block _) -> (
    {type: "ArrowFunctionExpression", params: fromNode <$> parameters, body: fromNode body, expression: false}
  ),
  ArrowFunctionExpression parameters body -> (
    {type: "ArrowFunctionExpression", params: fromNode <$> parameters, body: fromNode body, expression: true}
  ),
  AssignmentExpression operator left right -> (
    {type: "AssignmentExpression", operator, left: fromNode left, right: fromNode right}
  ),
  Block statements -> (
    {type: "BlockStatement", body: fromNode <$> statements}
  ),
  Boolean value -> (
    {type: "Literal", value}
  ),
  Break -> (
    {type: "BreakStatement", label: null}
  ),
  Call callee arguments -> (
    {type: "CallExpression", callee: fromNode callee, arguments: fromNode <$> arguments, optional: false}
  ),
  ConditionalExpression predicate consequent alternative -> (
    {type: "ConditionalExpression", test: fromNode predicate, consequent: fromNode consequent, alternate: fromNode alternative}
  ),
  ExportDefaultDeclaration declaration -> (
    {type: "ExportDefaultDeclaration", declaration: fromNode declaration}
  ),
  ExportNamedDeclaration specifiers -> (
    {type: "ExportNamedDeclaration", specifiers: fromNode <$> specifiers}
  ),
  ExportSpecifier local exported -> (
    {type: "ExportSpecifier", local: fromNode local, exported: fromNode exported}
  ),
  Expression expression -> (
    {type: "ExpressionStatement", expression: fromNode expression}
  ),
  For init test update body -> (
    {type: "ForStatement", init: fromNode init, test: fromNode test, update: fromNode update, body: fromNode body}
  ),
  FunctionExpression parameters body -> (
    {type: "FunctionExpression", params: fromNode <$> parameters, body: fromNode body, expression: false}
  ),
  Identifier name -> (
    fromEscapedIdentifierName $ escape name
  ),
  If predicate consequent alternative -> (
    {type: "IfStatement", test: fromNode predicate, consequent: fromNode consequent, alternate: maybe null fromNode alternative}
  ),
  ImportDeclaration source specifiers -> (
    {type: "ImportDeclaration", specifiers: fromNode <$> specifiers, source: fromNode source}
  ),
  ImportDefaultSpecifier local -> (
    {type: "ImportDefaultSpecifier", local: fromNode local}
  ),
  ImportNamespaceSpecifier local -> (
    {type: "ImportNamespaceSpecifier", local: fromNode local}
  ),
  ImportSpecifier imported local -> (
    {type: "ImportSpecifier", imported: fromNode imported, local: fromNode local}
  ),
  Infix operator left right -> case operator of [
    ":=" -> (
      {type: "AssignmentExpression", operator: "=", left: fromNode left, right: fromNode right}
    ),
    "&&" -> (
      {type: "LogicalExpression", operator: "&&", left: fromNode left, right: fromNode right}
    ),
    "||" -> (
      {type: "LogicalExpression", operator: "||", left: fromNode left, right: fromNode right}
    ),
    operator -> (
      {type: "BinaryExpression", operator, left: fromNode left, right: fromNode right}
    ),
  ],
  Member object property -> (
    fromMember object property
  ),
  Module imports exports statements -> (
    {type: "Program", sourceType: "module", body: fromNode <$> imports <> statements <> exports}
  ),
  Number value -> (
    {type: "Literal", value}
  ),
  Object properties -> (
    {type: "ObjectExpression", properties: fromNode <$> properties}
  ),
  Prefix operator operand -> (
    {type: "UnaryExpression", operator, argument: fromNode operand, prefix: true}
  ),
  Property key:(String keyValue) value -> {
    computed = not $ validEsIdentifierName keyValue;
    esKey = if computed then fromNode key else fromEscapedIdentifierName keyValue;
    esValue = fromNode value;
    shorthand = esKey.type == "Identifier" && esValue.type == "Identifier" && esKey.name == esValue.name;
    return {type: "Property", key: esKey, value: esValue, kind: "init", method: false, shorthand, computed};
  },
  Property key value -> {
    esKey = fromNode key;
    esValue = fromNode value;
    shorthand = esKey.type == "Identifier" && esValue.type == "Identifier" && esKey.name == esValue.name;
    return {type: "Property", key: esKey, value: esValue, kind: "init", method: false, shorthand, computed: true};
  },
  Return argument -> (
    {type: "ReturnStatement", argument: fromNode argument}
  ),
  Spread argument -> (
    {type: "SpreadElement", argument: fromNode argument}
  ),
  String value -> (
    {type: "Literal", value}
  ),
  This -> (
    {type: "ThisExpression"}
  ),
  Throw argument -> (
    {type: "ThrowStatement", argument: fromNode argument}
  ),
  UpdateExpression prefix? operator argument -> (
    {type: "UpdateExpression", prefix: prefix?, operator, argument: fromNode argument}
  ),
  Var kind pattern expression -> (
    {type: "VariableDeclaration", kind, declarations: [{type: "VariableDeclarator", id: fromNode pattern, init: fromNode expression}]}
  ),
  VarDeclaration identifier -> (
    {type: "VariableDeclaration", kind: "let", declarations: [{type: "VariableDeclarator", id: fromNode identifier, init: null}]}
  ),
  While predicate body -> (
    {type: "WhileStatement", test: fromNode predicate, body: fromNode body}
  ),
];
