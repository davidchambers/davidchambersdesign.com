import {maybe} from "./Maybe.serif";
import Node from "./Node.serif";

export default fromNode;

;; https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = construct Set [[
  ;; reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  ;; future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
  ;; reserved in strict mode
  "arguments",
  "eval",
]];

validEsIdentifierName name = {
  .test [name] $ RegExp "^[$_A-Za-z][$_A-Za-z0-9]*$"
};

fromEscapedIdentifierName name = {
  type: "Identifier",
  name,
};

fromIdentifier = {
  escapeChar c = {
    c
    % .charCodeAt [0]
    % .toString [16]
    % .toUpperCase []
    % .padStart [4, "0"]
    % concat "$"
  };
  escape name = {
    if name in ["eval", "import"] then name
    else if RESERVED_WORDS has name then name + "$"
    else if validEsIdentifierName name then name
    else .replaceAll [RegExp ("[^$_A-Za-z0-9]", "g"), escapeChar] name
  };
  fromEscapedIdentifierName . escape
};

TemplateElement tail raw = {
  type: "TemplateElement",
  tail,
  value: {
    raw,
  },
};

fromTemplateLiteral quasis expressions = {
  type: "TemplateLiteral",
  expressions: fromNode <$> expressions,
  quasis: {
    lineEnding = .find [\lineEnding -> .startsWith [lineEnding] quasis[0]] ["\n", "\r\n"];
    if lineEnding == undefined then {
      quasis' = .replaceAll ["`", "\\`"] <$> quasis;
      [
        ...{TemplateElement false <$> .slice [0, -1] quasis'},
        ...{TemplateElement true  <$> .slice [-1]    quasis'},
      ]
    } else {
      indent = .search [RegExp "(?! )"] $ .slice [lineEnding.length] quasis[0];
      pattern = RegExp (lineEnding + "[ ]{0," + indent + "}", "g");
      [head, ...tail] = (.replaceAll ["`", "\\`"] . .replaceAll [pattern, lineEnding]) <$> quasis;
      head' = .slice [lineEnding.length] head;
      if tail == [] then [
        TemplateElement true head',
      ] else [
        TemplateElement false head',
        ...{TemplateElement false <$> .slice [0, -1] tail},
        ...{TemplateElement true  <$> .slice [-1]    tail},
      ]
    }
  },
};

fromMemberExpression object property = {
  computed = not $ Node.matchOr (const false) {StringLiteral: validEsIdentifierName} property;
  {
    type: "MemberExpression",
    object: fromNode object,
    property: if computed then fromNode property else fromEscapedIdentifierName property.value,
    computed,
    optional: false,
  }
};

fromProperty key value = {
  computed = not $ Node.matchOr (const false) {StringLiteral: validEsIdentifierName} key;
  esKey = if computed then fromNode key else fromEscapedIdentifierName key.value;
  esValue = fromNode value;
  shorthand = esKey.type == "Identifier" && esValue.type == "Identifier" && esKey.name == esValue.name;
  {type: "Property", key: esKey, value: esValue, kind: "init", method: false, shorthand, computed}
};

fromBlock statements result = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: maybe id (\result -> (<> [{type: "ReturnStatement", argument: fromNode result}])) result $ fromNode <$> statements,
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

fromSwitchCase predicates consequent = {
  toReturnStatement node = {type: "ReturnStatement", argument: fromNode node};
  predicates.map \(pred, idx, preds) -> {
    type: "SwitchCase",
    test: maybe null fromNode pred,
    consequent: if idx + 1 < preds.length then [] else [
      consequent % Node.matchOr toReturnStatement {
        Block: \statements result -> {
          type: "BlockStatement",
          body: maybe id (append . toReturnStatement) result (fromNode <$> statements),
        }
      }
    ],
  }
};

fromSwitchExpression discriminant cases = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: [{
        type: "SwitchStatement",
        discriminant: fromNode discriminant,
        cases: cases >>= fromNode,
      }],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

fromNode = Node.match {
  NullLiteral:                {type: "Literal", value: null},
  BooleanLiteral:             \value -> {type: "Literal", value},
  NumberLiteral:              \value -> {type: "Literal", value},
  StringLiteral:              \value -> {type: "Literal", value},
  TemplateLiteral:            fromTemplateLiteral,
  MemberExpression:           fromMemberExpression,
  Identifier:                 fromIdentifier,
  ArrayExpression:            \elements -> {type: "ArrayExpression", elements: fromNode <$> elements},
  ObjectExpression:           \properties -> {type: "ObjectExpression", properties: fromNode <$> properties},
  ArrowFunctionExpression:    \parameters body -> { esBody = fromNode body; {type: "ArrowFunctionExpression", params: fromNode <$> parameters, body: esBody, expression: esBody.type != "BlockStatement"} },
  Block:                      fromBlock,
  PrefixExpression:           \operator operand -> {type: "UnaryExpression", operator, argument: fromNode operand, prefix: true},
  InfixExpression:            \operator left right -> {type: if operator in ["&&", "||", "??"] then "LogicalExpression" else "BinaryExpression", operator, left: fromNode left, right: fromNode right},
  ConditionalExpression:      \predicate consequent alternative -> {type: "ConditionalExpression", test: fromNode predicate, consequent: fromNode consequent, alternate: maybe {type: "Literal", value: undefined} fromNode alternative},
  SwitchExpression:           fromSwitchExpression,
  SwitchCase:                 fromSwitchCase,
  CallExpression:             \callee arguments -> {type: "CallExpression", callee: fromNode callee, arguments: fromNode <$> arguments, optional: false},
  SpreadElement:              \argument -> {type: "SpreadElement", argument: fromNode argument},
  ExpressionStatement:        \expression -> {type: "ExpressionStatement", expression: fromNode expression},
  VariableDeclaration:        \pattern expression -> {type: "VariableDeclaration", kind: "const", declarations: [{type: "VariableDeclarator", id: fromNode pattern, init: fromNode expression}]},
  Property:                   fromProperty,
  ArrayPattern:               \elements -> {type: "ArrayPattern", elements: fromNode <$> elements},
  Elision:                    null,
  ObjectPattern:              \properties -> {type: "ObjectPattern", properties: fromNode <$> properties},
  RestElement:                \argument -> {type: "RestElement", argument: fromNode argument},
  ImportDeclaration:          \source specifiers -> {type: "ImportDeclaration", specifiers: fromNode <$> specifiers, source: fromNode source},
  ImportDefaultSpecifier:     \local -> {type: "ImportDefaultSpecifier", local: fromNode local},
  ImportNamespaceSpecifier:   \local -> {type: "ImportNamespaceSpecifier", local: fromNode local},
  ImportSpecifier:            \imported local -> {type: "ImportSpecifier", imported: fromNode imported, local: fromNode local},
  ExportNamedDeclaration:     \specifiers -> {type: "ExportNamedDeclaration", specifiers: fromNode <$> specifiers},
  ExportDefaultDeclaration:   \declaration -> {type: "ExportDefaultDeclaration", declaration: fromNode declaration},
  ExportSpecifier:            \local exported -> {type: "ExportSpecifier", local: fromNode local, exported: fromNode exported},
  Module:                     \imports exports statements -> {type: "Program", sourceType: "module", body: fromNode <$> imports <> statements <> exports},
};
