import * as Future from "fluture";

export {toModule};

;; https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = Reflect.construct (Set, [[
  ;; reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  ;; future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
]]);

validEsIdentifierName name = {
  Reflect.apply (
    RegExp.prototype.test,
    RegExp ("^[a-z][a-z0-9]*$", "i"),
    [name]
  )
};

esFromIdentifierName = {
  escapeChar c = {
    "$" + c.charCodeAt(0).toString(16).toUpperCase().padStart(4, "0")
  };
  escape name = {
    if RESERVED_WORDS.has name then name + "$"
    else if validEsIdentifierName name then name
    else Reflect.apply (
      String.prototype.replace,
      name,
      [RegExp ("[^a-z0-9_$]", "gi"), escapeChar]
    )
  };
  name => esFromEscapedIdentifierName $ escape name
};

esFromEscapedIdentifierName name = {
  type: "Identifier",
  name: name,
};

esFromNullLiteral = {
  type: "Literal",
  value: null,
};

esFromLiteral {value} = {
  type: "Literal",
  value: value,
};

esFromMetaProperty = {meta, property} => {
  type: "MetaProperty",
  meta: esFromEscapedIdentifierName meta,
  property: esFromEscapedIdentifierName property,
};

esFromIdentifier {name} = {
  esFromIdentifierName name
};

esFromElision = null;

TemplateElement tail raw = {
  type: "TemplateElement",
  tail: tail,
  value: {
    raw: raw,
  },
};

esFromTemplateLiteral {expressions, quasis} = {
  type: "TemplateLiteral",
  expressions: esFromNode <$> expressions,
  quasis: {
    lineEnding = ["\n", "\r\n"].find (lineEnding => quasis[0].startsWith lineEnding);
    if lineEnding == undefined then [
      ...{TemplateElement false <$> quasis.slice (0, -1)},
      ...{TemplateElement true  <$> quasis.slice (-1)},
    ] else {
      indent = quasis[0].slice(lineEnding.length).search(RegExp "(?! )");
      pattern = RegExp (`${lineEnding}[ ]{0,${indent}}`, "g");
      [head, ...tail] = map (quasi => quasi.replace (pattern, lineEnding)) quasis;
      head' = head.slice lineEnding.length;
      if tail.length == 0 then [
        TemplateElement true head',
      ] else [
        TemplateElement false head',
        ...{TemplateElement false <$> tail.slice (0, -1)},
        ...{TemplateElement true  <$> tail.slice (-1)},
      ]
    }
  },
};

esFromMemberExpression {object, property} = {
  computed = !{
    property.type == "StringLiteral" and
    validEsIdentifierName property.value
  };
  {
    type: "MemberExpression",
    object: esFromNode object,
    property: if computed then esFromNode property else esFromEscapedIdentifierName property.value,
    computed: computed,
    optional: false,
  }
};

esFromSpreadElement {argument} = {
  type: "SpreadElement",
  argument: esFromNode argument,
};

esFromArrayExpression {elements} = {
  type: "ArrayExpression",
  elements: esFromNode <$> elements,
};

esFromProperty property = {
  if property.type == "SpreadElement" then esFromSpreadElement property else {
    computed = !{
      property.key.type == "StringLiteral" and
      validEsIdentifierName property.key.value
    };
    key = if computed then esFromNode property.key else esFromEscapedIdentifierName property.key.value;
    value = esFromNode property.value;
    shorthand = {
      key.type == "Identifier" and
      value.type == "Identifier" and
      key.name == value.name
    };
    {
      type: "Property",
      key: key,
      value: value,
      kind: "init",
      method: false,
      shorthand: shorthand,
      computed: computed,
    }
  }
};

esFromObjectExpression {properties} = {
  type: "ObjectExpression",
  properties: esFromProperty <$> properties,
};

esFromArrowFunctionExpression {parameters, body} = {
  esBody = esFromNode body;
  {
    type: "ArrowFunctionExpression",
    params: esFromNode <$> parameters,
    body: esBody,
    expression: esBody.type != "BlockStatement",
  }
};

esFromBlockExpression {statements} = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: {
        switch statements.at(-1).type
        when "VariableDeclaration" then [
          ...{esFromNode <$> statements},
        ]
        when "FunctionDeclaration" then [
          ...{esFromNode <$> statements},
          {type: "ReturnStatement", argument: {type: "Identifier", name: statements.at(-1).name}},
        ]
        when "ExpressionStatement" then [
          ...{esFromNode <$> statements.slice(0, -1)},
          {type: "ReturnStatement", argument: esFromNode $ statements.at(-1).expression},
        ]
      },
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromUnaryExpression {operator, argument} = {
  type: "UnaryExpression",
  operator: operator,
  argument: esFromNode argument,
  prefix: true,
};

esFromBinaryExpression {operator, left, right} = {
  type: "BinaryExpression",
  operator: {
    switch operator
    when "==" then "==="
    when "!=" then "!=="
    else operator
  },
  left: esFromNode left,
  right: esFromNode right,
};

esFromLogicalExpression {operator, left, right} = {
  type: "LogicalExpression",
  operator: {
    switch operator
    when "and" then "&&"
    when "or"  then "||"
    when "??"  then "??"
  },
  left: esFromNode left,
  right: esFromNode right,
};

esFromConditionalExpression {predicate, consequent, alternative} = {
  type: "ConditionalExpression",
  test: esFromNode predicate,
  consequent: esFromNode consequent,
  alternate: esFromNode alternative,
};

esFromSwitchCase {predicates, consequent} = {predicate => {
  type: "SwitchCase",
  test: esFromNode predicate,
  consequent: [{
    type: "ReturnStatement",
    argument: esFromNode consequent,
  }],
}} <$> predicates;

esFromSwitchExpression {discriminant, cases, default} = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: [{
        type: "SwitchStatement",
        discriminant: esFromNode discriminant,
        cases: {
          esCases = cases >>= esFromSwitchCase;
          if default == null then esCases else [...esCases, {
            type: "SwitchCase",
            test: null,
            consequent: [{
              type: "ReturnStatement",
              argument: esFromNode default,
            }],
          }]
        },
      }],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromCallExpression {callee, arguments: args} = {
  type: "CallExpression",
  callee: esFromNode callee,
  arguments: esFromNode <$> args,
  optional: false,
};

esFromVariableDeclaration {pattern, expression} = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromNode pattern,
    init: esFromNode expression,
  }],
};

esFromFunctionDeclaration {name, parameters, body} = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromIdentifierName name,
    init: parameters.reduceRight (
      (esBody, param) => {
        type: "ArrowFunctionExpression",
        params: [esFromNode param],
        body: esBody,
        expression: esBody.type != "BlockStatement",
      },
      esFromNode body
    ),
  }],
};

esFromExpressionStatement {expression} = {
  type: "ExpressionStatement",
  expression: esFromNode expression,
};

esFromArrayPattern {elements} = {
  type: "ArrayPattern",
  elements: esFromNode <$> elements,
};

esFromObjectPattern {properties} = {
  type: "ObjectPattern",
  properties: esFromNode <$> properties,
};

esFromRestElement {argument} = {
  type: "RestElement",
  argument: esFromNode argument,
};

esFromExportDefaultDeclaration {declaration} = {
  type: "ExportDefaultDeclaration",
  declaration: esFromNode declaration,
};

esFromExportNamedDeclaration {specifiers} = {
  type: "ExportNamedDeclaration",
  specifiers: {specifier => {
    type: "ExportSpecifier",
    local: esFromNode specifier,
    exported: esFromNode specifier,
  }} <$> specifiers,
};

esFromImportExpression {source} = {
  type: "ImportExpression",
  source: esFromNode source,
};

esFromImportDeclaration exportedNames importDeclaration = {
  if importDeclaration.specifiers == "*" then {
    source = importDeclaration.source.value;
    hiding = (.name) <$> importDeclaration.hiding;
    hiding! = Reflect.construct (Set, [(.name) <$> importDeclaration.hiding]);
    visible = name => !hiding!.delete(name);
    if source.endsWith ".serif" then {
      names = exportedNames(source).filter(visible);
      if hiding!.size > 0 then {
        Future.reject $ unnecessaryHiding (source, hiding, Array.from hiding!)
      } else {
        Future.resolve {
          type: "ImportDeclaration",
          specifiers: {
            name => {
              type: "ImportSpecifier",
              local: esFromIdentifierName name,
              imported: esFromIdentifierName name,
            }
          } <$> names,
          source: {
            type: "Literal",
            value: source.replace (RegExp "[.]serif$", ".js"),
          },
        }
      }
    } else {
      Future.attemptP (() => import (source))
      |> map Object.keys
      |> map (names => names.filter visible)
      |> chain (names =>
           if hiding!.size > 0 then {
             Future.reject $ unnecessaryHiding (source, hiding, Array.from hiding!)
           } else {
             Future.resolve {
               type: "ImportDeclaration",
               specifiers: {
                 name => {
                   type: "ImportSpecifier",
                   local: esFromEscapedIdentifierName name,
                   imported: esFromEscapedIdentifierName name,
                 }
               } <$> names,
               source: {
                 type: "Literal",
                 value: source,
               },
             }
           }
         )
    }
  } else {
    Future.resolve {
      type: "ImportDeclaration",
      specifiers: {
        specifier => {
          switch specifier.type
          when "ImportDefaultSpecifier" then {
            type: "ImportDefaultSpecifier",
            local: esFromIdentifier specifier.local,
          }
          when "ImportNamespaceSpecifier" then {
            type: "ImportNamespaceSpecifier",
            local: esFromIdentifier specifier.local,
          }
          when "ImportSpecifier" then {
            type: "ImportSpecifier",
            local: esFromIdentifier specifier.local,
            imported: esFromIdentifier specifier.imported,
          }
        }
      } <$> importDeclaration.specifiers,
      source: {
        type: "Literal",
        value: importDeclaration.source.value.replace(RegExp "[.]serif$", ".js"),
      },
    }
  }
};

esFromNode expr = {
  switch expr.type
  when "NullLiteral"              then esFromNullLiteral
  when "BooleanLiteral"           then esFromLiteral expr
  when "NumberLiteral"            then esFromLiteral expr
  when "StringLiteral"            then esFromLiteral expr
  when "TemplateLiteral"          then esFromTemplateLiteral expr
  when "MetaProperty"             then esFromMetaProperty expr
  when "MemberExpression"         then esFromMemberExpression expr
  when "Identifier"               then esFromIdentifier expr
  when "ArrayExpression"          then esFromArrayExpression expr
  when "ObjectExpression"         then esFromObjectExpression expr
  when "ArrowFunctionExpression"  then esFromArrowFunctionExpression expr
  when "BlockExpression"          then esFromBlockExpression expr
  when "UnaryExpression"          then esFromUnaryExpression expr
  when "BinaryExpression"         then esFromBinaryExpression expr
  when "LogicalExpression"        then esFromLogicalExpression expr
  when "ConditionalExpression"    then esFromConditionalExpression expr
  when "SwitchExpression"         then esFromSwitchExpression expr
  when "CallExpression"           then esFromCallExpression expr
  when "SpreadElement"            then esFromSpreadElement expr
  when "ExpressionStatement"      then esFromExpressionStatement expr
  when "VariableDeclaration"      then esFromVariableDeclaration expr
  when "FunctionDeclaration"      then esFromFunctionDeclaration expr
  when "Property"                 then esFromProperty expr
  when "ArrayPattern"             then esFromArrayPattern expr
  when "Elision"                  then esFromElision
  when "ObjectPattern"            then esFromObjectPattern expr
  when "RestElement"              then esFromRestElement expr
  when "ExportNamedDeclaration"   then esFromExportNamedDeclaration expr
  when "ExportDefaultDeclaration" then esFromExportDefaultDeclaration expr
  when "ImportExpression"         then esFromImportExpression expr
};

unnecessaryHiding = (
  source,
  hiding,
  names,
) => Reflect.construct (Error, [
  `import * from "${
    source
  }" hiding {${
    hiding.join(", ")
  }};\n\n${
    if names.length > 2
    then names.slice(0, -1).join(", ") + ", and " + names.at(-1)
    else names.join(" and ")
  } ${
    if names.length == 1 then "is" else "are"
  } not exported so need not be hidden.\n`,
]);

toModule module exportedNames = {
  module.imports
  |> map (esFromImportDeclaration exportedNames)
  |> Future.parallel 16
  |> map (imports => {
       type: "Program",
       sourceType: "module",
       body: [
         ...imports,
         ...{
           module.statements >>= statement => {
             switch statement.type
             when "VariableDeclaration",
                  "FunctionDeclaration",
                  "ExpressionStatement"
             then [esFromNode statement]
             else []
           }
         },
         ...{{
           statement => {
             switch statement.type
             when "ExportNamedDeclaration"
             then esFromExportNamedDeclaration statement
             when "ExportDefaultDeclaration"
             then esFromExportDefaultDeclaration statement
           }
         } <$> module.exports},
       ],
     })
};
