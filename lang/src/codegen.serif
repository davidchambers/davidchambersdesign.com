export default esFromNode;

;; https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = construct Set [[
  ;; reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  ;; future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
  ;; reserved in strict mode
  "arguments",
  "eval",
]];

validEsIdentifierName name = {
  .test [name] $ RegExp "^[$_A-Za-z][$_A-Za-z0-9]*$"
};

esFromIdentifierName = {
  escapeChar c = {
    c
    |> .charCodeAt [0]
    |> .toString [16]
    |> .toUpperCase []
    |> .padStart [4, "0"]
    |> concat "$"
  };
  escape name = {
    if name is "import" then "import"
    else if .has [name] RESERVED_WORDS then name + "$"
    else if validEsIdentifierName name then name
    else .replaceAll [apply ["[^$_A-Za-z0-9]", "g"] RegExp, escapeChar] name
  };
  esFromEscapedIdentifierName . escape
};

esFromEscapedIdentifierName name = {
  type: "Identifier",
  name,
};

esFromNullLiteral = {
  type: "Literal",
  value: null,
};

esFromLiteral {value} = {
  type: "Literal",
  value,
};

esFromIdentifier {name} = {
  esFromIdentifierName name
};

esFromElision = null;

TemplateElement tail raw = {
  type: "TemplateElement",
  tail,
  value: {
    raw,
  },
};

esFromTemplateLiteral {expressions, quasis} = {
  type: "TemplateLiteral",
  expressions: esFromNode <$> expressions,
  quasis: {
    lineEnding = .find [lineEnding => .startsWith [lineEnding] quasis[0]] ["\n", "\r\n"];
    if lineEnding is undefined then [
      ...{TemplateElement false <$> .slice [0, -1] quasis},
      ...{TemplateElement true  <$> .slice [-1]    quasis},
    ] else {
      indent = .search [RegExp "(?! )"] $ .slice [lineEnding.length] quasis[0];
      pattern = apply [`${lineEnding}[ ]{0,${indent}}`, "g"] RegExp;
      [head, ...tail] = .replace [pattern, lineEnding] <$> quasis;
      head' = .slice [lineEnding.length] head;
      if tail.length is 0 then [
        TemplateElement true head',
      ] else [
        TemplateElement false head',
        ...{TemplateElement false <$> .slice [0, -1] tail},
        ...{TemplateElement true  <$> .slice [-1]    tail},
      ]
    }
  },
};

esFromMemberExpression {object, property} = {
  computed = not {
    property.type is "StringLiteral" and
    validEsIdentifierName property.value
  };
  {
    type: "MemberExpression",
    object: esFromNode object,
    property: if computed then esFromNode property else esFromEscapedIdentifierName property.value,
    computed,
    optional: false,
  }
};

esFromSpreadElement {argument} = {
  type: "SpreadElement",
  argument: esFromNode argument,
};

esFromArrayExpression {elements} = {
  type: "ArrayExpression",
  elements: esFromNode <$> elements,
};

esFromProperty property = {
  if property.type is "SpreadElement" then esFromSpreadElement property else {
    computed = not {
      property.key.type is "StringLiteral" and
      validEsIdentifierName property.key.value
    };
    key = if computed then esFromNode property.key else esFromEscapedIdentifierName property.key.value;
    value = esFromNode property.value;
    shorthand = {
      key.type is "Identifier" and
      value.type is "Identifier" and
      key.name is value.name
    };
    {
      type: "Property",
      key,
      value,
      kind: "init",
      method: false,
      shorthand,
      computed,
    }
  }
};

esFromObjectExpression {properties} = {
  type: "ObjectExpression",
  properties: esFromProperty <$> properties,
};

esFromArrowFunctionExpression {parameters, body} = {
  esBody = esFromNode body;
  {
    type: "ArrowFunctionExpression",
    params: esFromNode <$> parameters,
    body: esBody,
    expression: not $ esBody.type is "BlockStatement",
  }
};

esFromBlockExpression {statements} = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: {
        switch (.type) $ .at [-1] statements
        when "VariableDeclaration" then [
          ...{esFromNode <$> statements},
        ]
        when "FunctionDeclaration" then [
          ...{esFromNode <$> statements},
          {type: "ReturnStatement", argument: {type: "Identifier", name: (.name) $ .at [-1] statements}},
        ]
        when "ExpressionStatement" then [
          ...{esFromNode <$> .slice [0, -1] statements},
          {type: "ReturnStatement", argument: esFromNode $ (.expression) $ .at [-1] statements},
        ]
      },
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromUnaryExpression {operator, argument} = {
  type: "UnaryExpression",
  operator,
  argument: esFromNode argument,
  prefix: true,
};

esFromBinaryExpression {operator, left, right} = {
  type: "BinaryExpression",
  operator,
  left: esFromNode left,
  right: esFromNode right,
};

esFromLogicalExpression {operator, left, right} = {
  type: "LogicalExpression",
  operator: {
    switch operator
    when "and" then "&&"
    when "or"  then "||"
    when "??"  then "??"
  },
  left: esFromNode left,
  right: esFromNode right,
};

esFromConditionalExpression {predicate, consequent, alternative} = {
  type: "ConditionalExpression",
  test: esFromNode predicate,
  consequent: esFromNode consequent,
  alternate: esFromNode alternative,
};

esFromSwitchCase {predicates, consequent} = {predicate => {
  type: "SwitchCase",
  test: esFromNode predicate,
  consequent: [{
    type: "ReturnStatement",
    argument: esFromNode consequent,
  }],
}} <$> predicates;

esFromSwitchExpression {discriminant, cases, default} = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: [{
        type: "SwitchStatement",
        discriminant: esFromNode discriminant,
        cases: {
          esCases = cases >>= esFromSwitchCase;
          if default is null then esCases else [...esCases, {
            type: "SwitchCase",
            test: null,
            consequent: [{
              type: "ReturnStatement",
              argument: esFromNode default,
            }],
          }]
        },
      }],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromCallExpression {callee, arguments: args} = {
  type: "CallExpression",
  callee: esFromNode callee,
  arguments: esFromNode <$> args,
  optional: false,
};

esFromVariableDeclaration {pattern, expression} = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromNode pattern,
    init: esFromNode expression,
  }],
};

esFromFunctionDeclaration {name, parameters, body} = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromIdentifierName name,
    init: .reduceRight [
      (esBody, param) => {
        type: "ArrowFunctionExpression",
        params: [esFromNode param],
        body: esBody,
        expression: not $ esBody.type is "BlockStatement",
      },
      esFromNode body,
    ] parameters,
  }],
};

esFromExpressionStatement {expression} = {
  type: "ExpressionStatement",
  expression: esFromNode expression,
};

esFromArrayPattern {elements} = {
  type: "ArrayPattern",
  elements: esFromNode <$> elements,
};

esFromObjectPattern {properties} = {
  type: "ObjectPattern",
  properties: esFromNode <$> properties,
};

esFromRestElement {argument} = {
  type: "RestElement",
  argument: esFromNode argument,
};

esFromExportDefaultDeclaration {declaration} = {
  type: "ExportDefaultDeclaration",
  declaration: esFromNode declaration,
};

esFromExportNamedDeclaration {specifiers} = {
  type: "ExportNamedDeclaration",
  specifiers: {specifier => {
    type: "ExportSpecifier",
    local: esFromNode specifier,
    exported: esFromNode specifier,
  }} <$> specifiers,
};

esFromImportDefaultSpecifier {local} = {
  type: "ImportDefaultSpecifier",
  local: esFromIdentifier local,
};

esFromImportNamespaceSpecifier {local} = {
  type: "ImportNamespaceSpecifier",
  local: esFromIdentifier local,
};

esFromImportSpecifier {local, imported} = {
  type: "ImportSpecifier",
  local: esFromIdentifier local,
  imported: esFromIdentifier imported,
};

esFromImportDeclaration {source, specifiers} = {
  type: "ImportDeclaration",
  specifiers: esFromNode <$> specifiers,
  source: esFromNode source,
};

esFromModule {imports, exports, statements} = {
  type: "Program",
  sourceType: "module",
  body: esFromNode <$> imports <> statements <> exports,
};

esFromNode expr = {
  switch expr.type
  when "NullLiteral"              then esFromNullLiteral
  when "BooleanLiteral"           then esFromLiteral expr
  when "NumberLiteral"            then esFromLiteral expr
  when "StringLiteral"            then esFromLiteral expr
  when "TemplateLiteral"          then esFromTemplateLiteral expr
  when "MemberExpression"         then esFromMemberExpression expr
  when "Identifier"               then esFromIdentifier expr
  when "ArrayExpression"          then esFromArrayExpression expr
  when "ObjectExpression"         then esFromObjectExpression expr
  when "ArrowFunctionExpression"  then esFromArrowFunctionExpression expr
  when "BlockExpression"          then esFromBlockExpression expr
  when "UnaryExpression"          then esFromUnaryExpression expr
  when "BinaryExpression"         then esFromBinaryExpression expr
  when "LogicalExpression"        then esFromLogicalExpression expr
  when "ConditionalExpression"    then esFromConditionalExpression expr
  when "SwitchExpression"         then esFromSwitchExpression expr
  when "CallExpression"           then esFromCallExpression expr
  when "SpreadElement"            then esFromSpreadElement expr
  when "ExpressionStatement"      then esFromExpressionStatement expr
  when "VariableDeclaration"      then esFromVariableDeclaration expr
  when "FunctionDeclaration"      then esFromFunctionDeclaration expr
  when "Property"                 then esFromProperty expr
  when "ArrayPattern"             then esFromArrayPattern expr
  when "Elision"                  then esFromElision
  when "ObjectPattern"            then esFromObjectPattern expr
  when "RestElement"              then esFromRestElement expr
  when "ImportDeclaration"        then esFromImportDeclaration expr
  when "ImportDefaultSpecifier"   then esFromImportDefaultSpecifier expr
  when "ImportNamespaceSpecifier" then esFromImportNamespaceSpecifier expr
  when "ImportSpecifier"          then esFromImportSpecifier expr
  when "ExportNamedDeclaration"   then esFromExportNamedDeclaration expr
  when "ExportDefaultDeclaration" then esFromExportDefaultDeclaration expr
  when "Module"                   then esFromModule expr
};
