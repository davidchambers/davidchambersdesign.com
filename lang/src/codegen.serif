import Node from "./Node.js";

export default esFromNode;

;; https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = construct Set [[
  ;; reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  ;; future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
  ;; reserved in strict mode
  "arguments",
  "eval",
]];

validEsIdentifierName name = {
  .test [name] $ RegExp "^[$_A-Za-z][$_A-Za-z0-9]*$"
};

esFromEscapedIdentifierName name = {
  type: "Identifier",
  name,
};

esFromIdentifier = {
  escapeChar c = {
    c
    |> .charCodeAt [0]
    |> .toString [16]
    |> .toUpperCase []
    |> .padStart [4, "0"]
    |> concat "$"
  };
  escape name = {
    if name == "import" then "import"
    else if .has [name] RESERVED_WORDS then name + "$"
    else if validEsIdentifierName name then name
    else .replaceAll [apply ["[^$_A-Za-z0-9]", "g"] RegExp, escapeChar] name
  };
  esFromEscapedIdentifierName . escape
};

esFromLiteral value = {
  type: "Literal",
  value,
};

esFromElision = null;

TemplateElement tail raw = {
  type: "TemplateElement",
  tail,
  value: {
    raw,
  },
};

esFromTemplateLiteral quasis expressions = {
  type: "TemplateLiteral",
  expressions: esFromNode <$> expressions,
  quasis: {
    lineEnding = .find [\lineEnding -> .startsWith [lineEnding] quasis[0]] ["\n", "\r\n"];
    if lineEnding == undefined then [
      ...{TemplateElement false <$> .slice [0, -1] quasis},
      ...{TemplateElement true  <$> .slice [-1]    quasis},
    ] else {
      indent = .search [RegExp "(?! )"] $ .slice [lineEnding.length] quasis[0];
      pattern = apply [`${lineEnding}[ ]{0,${indent}}`, "g"] RegExp;
      [head, ...tail] = .replace [pattern, lineEnding] <$> quasis;
      head' = .slice [lineEnding.length] head;
      if tail == [] then [
        TemplateElement true head',
      ] else [
        TemplateElement false head',
        ...{TemplateElement false <$> .slice [0, -1] tail},
        ...{TemplateElement true  <$> .slice [-1]    tail},
      ]
    }
  },
};

esFromMemberExpression object property = {
  computed = not $ match' Node (const false) {StringLiteral: validEsIdentifierName} property;
  {
    type: "MemberExpression",
    object: esFromNode object,
    property: if computed then esFromNode property else esFromEscapedIdentifierName property.value,
    computed,
    optional: false,
  }
};

esFromSpreadElement argument = {
  type: "SpreadElement",
  argument: esFromNode argument,
};

esFromArrayExpression elements = {
  type: "ArrayExpression",
  elements: esFromNode <$> elements,
};

esFromProperty key value = {
  computed = not $ match' Node (const false) {StringLiteral: validEsIdentifierName} key;
  esKey = if computed then esFromNode key else esFromEscapedIdentifierName key.value;
  esValue = esFromNode value;
  shorthand = esKey.type == "Identifier" and esValue.type == "Identifier" and esKey.name == esValue.name;
  {type: "Property", key: esKey, value: esValue, kind: "init", method: false, shorthand, computed}
};

esFromObjectExpression properties = {
  type: "ObjectExpression",
  properties: esFromNode <$> properties,
};

esFromArrowFunctionExpression parameters body = {
  esBody = esFromNode body;
  {
    type: "ArrowFunctionExpression",
    params: esFromNode <$> parameters,
    body: esBody,
    expression: esBody.type != "BlockStatement",
  }
};

esFromBlockExpression statements = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: match Node {
        VariableDeclaration: \pattern expression init -> (
          (esFromNode <$> init <> Node.VariableDeclaration pattern expression)
        ),
        FunctionDeclaration: \name parameters body init -> (
          (esFromNode <$> init <> Node.FunctionDeclaration name parameters body)
          <> [{type: "ReturnStatement", argument: {type: "Identifier", name}}]
        ),
        ExpressionStatement: \expression init -> (
          (esFromNode <$> init)
          <> [{type: "ReturnStatement", argument: esFromNode expression}]
        ),
      } (.at [-1] statements) (.slice [0, -1] statements),
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromUnaryExpression operator argument = {
  type: "UnaryExpression",
  operator,
  argument: esFromNode argument,
  prefix: true,
};

esFromBinaryExpression operator left right = {
  type: "BinaryExpression",
  operator,
  left: esFromNode left,
  right: esFromNode right,
};

esFromLogicalExpression operator left right = {
  type: "LogicalExpression",
  operator: {
    switch operator
    when "and" then "&&"
    when "or"  then "||"
    when "??"  then "??"
  },
  left: esFromNode left,
  right: esFromNode right,
};

esFromConditionalExpression predicate consequent alternative = {
  type: "ConditionalExpression",
  test: esFromNode predicate,
  consequent: esFromNode consequent,
  alternate: esFromNode alternative,
};

esFromSwitchCase {predicates, consequent} = {\predicate -> {
  type: "SwitchCase",
  test: esFromNode predicate,
  consequent: [{
    type: "ReturnStatement",
    argument: esFromNode consequent,
  }],
}} <$> predicates;

esFromSwitchExpression discriminant cases default = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: [{
        type: "SwitchStatement",
        discriminant: esFromNode discriminant,
        cases: {
          esCases = cases >>= esFromSwitchCase;
          if default == null then esCases else [...esCases, {
            type: "SwitchCase",
            test: null,
            consequent: [{
              type: "ReturnStatement",
              argument: esFromNode default,
            }],
          }]
        },
      }],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

esFromCallExpression callee arguments = {
  type: "CallExpression",
  callee: esFromNode callee,
  arguments: esFromNode <$> arguments,
  optional: false,
};

esFromVariableDeclaration pattern expression = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromNode pattern,
    init: esFromNode expression,
  }],
};

esFromFunctionDeclaration name parameters body = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: esFromIdentifier name,
    init: {
      reduceRight (\esBody param -> {
                     type: "ArrowFunctionExpression",
                     params: [esFromNode param],
                     body: esBody,
                     expression: esBody.type != "BlockStatement",
                   })
                  (esFromNode body)
                  parameters
    },
  }],
};

esFromExpressionStatement expression = {
  type: "ExpressionStatement",
  expression: esFromNode expression,
};

esFromArrayPattern elements = {
  type: "ArrayPattern",
  elements: esFromNode <$> elements,
};

esFromObjectPattern properties = {
  type: "ObjectPattern",
  properties: esFromNode <$> properties,
};

esFromRestElement argument = {
  type: "RestElement",
  argument: esFromNode argument,
};

esFromExportDefaultDeclaration declaration = {
  type: "ExportDefaultDeclaration",
  declaration: esFromNode declaration,
};

esFromExportNamedDeclaration specifiers = {
  type: "ExportNamedDeclaration",
  specifiers: esFromNode <$> specifiers,
};

esFromExportSpecifier local exported = {
  type: "ExportSpecifier",
  local: esFromNode local,
  exported: esFromNode exported,
};

esFromImportDefaultSpecifier local = {
  type: "ImportDefaultSpecifier",
  local: esFromNode local,
};

esFromImportNamespaceSpecifier local = {
  type: "ImportNamespaceSpecifier",
  local: esFromNode local,
};

esFromImportSpecifier local imported = {
  type: "ImportSpecifier",
  local: esFromNode local,
  imported: esFromNode imported,
};

esFromImportDeclaration source specifiers = {
  type: "ImportDeclaration",
  specifiers: esFromNode <$> specifiers,
  source: esFromNode source,
};

esFromModule imports exports statements = {
  type: "Program",
  sourceType: "module",
  body: esFromNode <$> imports <> statements <> exports,
};

esFromNode = match Node {
  NullLiteral:                esFromLiteral null,
  BooleanLiteral:             esFromLiteral,
  NumberLiteral:              esFromLiteral,
  StringLiteral:              esFromLiteral,
  TemplateLiteral:            esFromTemplateLiteral,
  MemberExpression:           esFromMemberExpression,
  Identifier:                 esFromIdentifier,
  ArrayExpression:            esFromArrayExpression,
  ObjectExpression:           esFromObjectExpression,
  ArrowFunctionExpression:    esFromArrowFunctionExpression,
  BlockExpression:            esFromBlockExpression,
  UnaryExpression:            esFromUnaryExpression,
  BinaryExpression:           esFromBinaryExpression,
  LogicalExpression:          esFromLogicalExpression,
  ConditionalExpression:      esFromConditionalExpression,
  SwitchExpression:           esFromSwitchExpression,
  CallExpression:             esFromCallExpression,
  SpreadElement:              esFromSpreadElement,
  ExpressionStatement:        esFromExpressionStatement,
  VariableDeclaration:        esFromVariableDeclaration,
  FunctionDeclaration:        esFromFunctionDeclaration,
  Property:                   esFromProperty,
  ArrayPattern:               esFromArrayPattern,
  Elision:                    esFromElision,
  ObjectPattern:              esFromObjectPattern,
  RestElement:                esFromRestElement,
  ImportDeclaration:          esFromImportDeclaration,
  ImportDefaultSpecifier:     esFromImportDefaultSpecifier,
  ImportNamespaceSpecifier:   esFromImportNamespaceSpecifier,
  ImportSpecifier:            esFromImportSpecifier,
  ExportNamedDeclaration:     esFromExportNamedDeclaration,
  ExportDefaultDeclaration:   esFromExportDefaultDeclaration,
  ExportSpecifier:            esFromExportSpecifier,
  Module:                     esFromModule,
};
