import Maybe from "./Maybe.serif";
import Node from "./Node.serif";

export default fromNode;

;; https://262.ecma-international.org/13.0/#sec-keywords-and-reserved-words
RESERVED_WORDS = construct Set [[
  ;; reserved words
  "await",
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "enum",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  "yield",
  ;; future reserved words
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public",
  ;; reserved in strict mode
  "arguments",
  "eval",
]];

validEsIdentifierName name = {
  .test [name] $ RegExp "^[$_A-Za-z][$_A-Za-z0-9]*$"
};

fromEscapedIdentifierName name = {
  type: "Identifier",
  name,
};

fromIdentifier = {
  escapeChar c = {
    c
    | .charCodeAt [0]
    | .toString [16]
    | .toUpperCase []
    | .padStart [4, "0"]
    | concat "$"
  };
  escape name = {
    if name == "import" then "import"
    else if .has [name] RESERVED_WORDS then name + "$"
    else if validEsIdentifierName name then name
    else .replaceAll [apply RegExp ["[^$_A-Za-z0-9]", "g"], escapeChar] name
  };
  fromEscapedIdentifierName . escape
};

fromLiteral value = {
  type: "Literal",
  value,
};

fromElision = null;

TemplateElement tail raw = {
  type: "TemplateElement",
  tail,
  value: {
    raw,
  },
};

fromTemplateLiteral quasis expressions = {
  type: "TemplateLiteral",
  expressions: fromNode <$> expressions,
  quasis: {
    lineEnding = .find [\lineEnding -> .startsWith [lineEnding] quasis[0]] ["\n", "\r\n"];
    if lineEnding == undefined then {
      quasis' = .replaceAll ["`", "\\`"] <$> quasis;
      [
        ...{TemplateElement false <$> .slice [0, -1] quasis'},
        ...{TemplateElement true  <$> .slice [-1]    quasis'},
      ]
    } else {
      indent = .search [RegExp "(?! )"] $ .slice [lineEnding.length] quasis[0];
      pattern = apply RegExp [lineEnding + "[ ]{0," + indent + "}", "g"];
      [head, ...tail] = (.replaceAll ["`", "\\`"] . .replaceAll [pattern, lineEnding]) <$> quasis;
      head' = .slice [lineEnding.length] head;
      if tail == [] then [
        TemplateElement true head',
      ] else [
        TemplateElement false head',
        ...{TemplateElement false <$> .slice [0, -1] tail},
        ...{TemplateElement true  <$> .slice [-1]    tail},
      ]
    }
  },
};

fromMemberExpression object property = {
  computed = not $ match' Node (const false) {StringLiteral: validEsIdentifierName} property;
  {
    type: "MemberExpression",
    object: fromNode object,
    property: if computed then fromNode property else fromEscapedIdentifierName property.value,
    computed,
    optional: false,
  }
};

fromSpreadElement argument = {
  type: "SpreadElement",
  argument: fromNode argument,
};

fromArrayExpression elements = {
  type: "ArrayExpression",
  elements: fromNode <$> elements,
};

fromProperty key value = {
  computed = not $ match' Node (const false) {StringLiteral: validEsIdentifierName} key;
  esKey = if computed then fromNode key else fromEscapedIdentifierName key.value;
  esValue = fromNode value;
  shorthand = esKey.type == "Identifier" and esValue.type == "Identifier" and esKey.name == esValue.name;
  {type: "Property", key: esKey, value: esValue, kind: "init", method: false, shorthand, computed}
};

fromObjectExpression properties = {
  type: "ObjectExpression",
  properties: fromNode <$> properties,
};

fromArrowFunctionExpression parameters body = {
  esBody = fromNode body;
  {
    type: "ArrowFunctionExpression",
    params: fromNode <$> parameters,
    body: esBody,
    expression: esBody.type != "BlockStatement",
  }
};

fromBlockExpression statements result = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: map fromNode statements <> [{type: "ReturnStatement", argument: fromNode result}],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

fromBlockStatement statements = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: fromNode <$> statements,
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

fromUnaryExpression operator argument = {
  type: "UnaryExpression",
  operator,
  argument: fromNode argument,
  prefix: true,
};

fromBinaryExpression operator left right = {
  type: "BinaryExpression",
  operator,
  left: fromNode left,
  right: fromNode right,
};

fromLogicalExpression operator left right = {
  type: "LogicalExpression",
  operator: {
    switch operator
    when "and" then "&&"
    when "or"  then "||"
    when "??"  then "??"
  },
  left: fromNode left,
  right: fromNode right,
};

fromConditionalExpression predicate consequent alternative = {
  type: "ConditionalExpression",
  test: fromNode predicate,
  consequent: fromNode consequent,
  alternate: Maybe.maybe (fromLiteral undefined) fromNode alternative,
};

fromSwitchCase consequent predicate = {
  type: "SwitchCase",
  test: Maybe.maybe null fromNode predicate,
  consequent: {
    consequent
    | map fromNode
    | map (\argument -> {type: "ReturnStatement", argument})
    | Maybe.maybe [] Array.of
  },
};

fromSwitchCases predicates consequent = {
  init = .slice [0, -1] predicates;
  last = .at       [-1] predicates;
  map (fromSwitchCase Maybe.Nothing) init <> [fromSwitchCase (Maybe.Just consequent) last]
};

fromSwitchExpression discriminant cases = {
  type: "CallExpression",
  callee: {
    type: "ArrowFunctionExpression",
    params: [],
    body: {
      type: "BlockStatement",
      body: [{
        type: "SwitchStatement",
        discriminant: fromNode discriminant,
        cases: cases >>= fromNode,
      }],
    },
    expression: false,
  },
  arguments: [],
  optional: false,
};

fromCallExpression callee arguments = {
  type: "CallExpression",
  callee: fromNode callee,
  arguments: fromNode <$> arguments,
  optional: false,
};

fromVariableDeclaration pattern expression = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: fromNode pattern,
    init: fromNode expression,
  }],
};

fromFunctionDeclaration name parameters body = {
  type: "VariableDeclaration",
  kind: "const",
  declarations: [{
    type: "VariableDeclarator",
    id: fromIdentifier name,
    init: {
      reduceRight (\esBody param -> {
                     type: "ArrowFunctionExpression",
                     params: [fromNode param],
                     body: esBody,
                     expression: esBody.type != "BlockStatement",
                   })
                  (fromNode body)
                  parameters
    },
  }],
};

fromExpressionStatement expression = {
  type: "ExpressionStatement",
  expression: fromNode expression,
};

fromArrayPattern elements = {
  type: "ArrayPattern",
  elements: fromNode <$> elements,
};

fromObjectPattern properties = {
  type: "ObjectPattern",
  properties: fromNode <$> properties,
};

fromRestElement argument = {
  type: "RestElement",
  argument: fromNode argument,
};

fromExportDefaultDeclaration declaration = {
  type: "ExportDefaultDeclaration",
  declaration: fromNode declaration,
};

fromExportNamedDeclaration specifiers = {
  type: "ExportNamedDeclaration",
  specifiers: fromNode <$> specifiers,
};

fromExportSpecifier local exported = {
  type: "ExportSpecifier",
  local: fromNode local,
  exported: fromNode exported,
};

fromImportDefaultSpecifier local = {
  type: "ImportDefaultSpecifier",
  local: fromNode local,
};

fromImportNamespaceSpecifier local = {
  type: "ImportNamespaceSpecifier",
  local: fromNode local,
};

fromImportSpecifier imported local = {
  type: "ImportSpecifier",
  imported: fromNode imported,
  local: fromNode local,
};

fromImportDeclaration source specifiers = {
  type: "ImportDeclaration",
  specifiers: fromNode <$> specifiers,
  source: fromNode source,
};

fromModule imports exports statements = {
  type: "Program",
  sourceType: "module",
  body: fromNode <$> imports <> statements <> exports,
};

fromNode = match Node {
  NullLiteral:                fromLiteral null,
  BooleanLiteral:             fromLiteral,
  NumberLiteral:              fromLiteral,
  StringLiteral:              fromLiteral,
  TemplateLiteral:            fromTemplateLiteral,
  MemberExpression:           fromMemberExpression,
  Identifier:                 fromIdentifier,
  ArrayExpression:            fromArrayExpression,
  ObjectExpression:           fromObjectExpression,
  ArrowFunctionExpression:    fromArrowFunctionExpression,
  BlockExpression:            fromBlockExpression,
  BlockStatement:             fromBlockStatement,
  UnaryExpression:            fromUnaryExpression,
  BinaryExpression:           fromBinaryExpression,
  LogicalExpression:          fromLogicalExpression,
  ConditionalExpression:      fromConditionalExpression,
  SwitchExpression:           fromSwitchExpression,
  SwitchCase:                 fromSwitchCases,
  CallExpression:             fromCallExpression,
  SpreadElement:              fromSpreadElement,
  ExpressionStatement:        fromExpressionStatement,
  VariableDeclaration:        fromVariableDeclaration,
  FunctionDeclaration:        fromFunctionDeclaration,
  Property:                   fromProperty,
  ArrayPattern:               fromArrayPattern,
  Elision:                    fromElision,
  ObjectPattern:              fromObjectPattern,
  RestElement:                fromRestElement,
  ImportDeclaration:          fromImportDeclaration,
  ImportDefaultSpecifier:     fromImportDefaultSpecifier,
  ImportNamespaceSpecifier:   fromImportNamespaceSpecifier,
  ImportSpecifier:            fromImportSpecifier,
  ExportNamedDeclaration:     fromExportNamedDeclaration,
  ExportDefaultDeclaration:   fromExportDefaultDeclaration,
  ExportSpecifier:            fromExportSpecifier,
  Module:                     fromModule,
};
