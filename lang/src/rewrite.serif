import * as Future from "fluture";

import {Nothing, Just, maybe} from "./Maybe.serif";
import Node, * from "./Node.serif";
import * as format from "./format.serif";
import globals from "./globals.serif";
import Prelude from "./prelude.serif";

export default rewriteModule;

preludeNames = construct Set [Object.keys Prelude];

variables declared referenced = {declared, referenced};
declaring   names = variables names (empty Set);
referencing names = variables (empty Set) names;
emptyVariables    = variables (empty Set) (empty Set);

referenced = (.referenced);

merge lhs rhs = {
  declared:   lhs.declared   | rhs.declared,
  referenced: lhs.referenced | rhs.referenced,
};

mergeAll = reduce merge emptyVariables;

vars node = flip (match' Node $ const emptyVariables) node {
  TemplateLiteral: const $ mergeAll . map vars,
  MemberExpression: \object property -> vars object `merge` vars property,
  Identifier: referencing . of Set,
  SpreadElement: vars,
  ArrayExpression: mergeAll . map vars,
  Property: \key value -> vars key `merge` vars value,
  ObjectExpression: mergeAll . map vars,
  ArrayPattern: mergeAll . map vars,
  ObjectPattern: mergeAll . map vars,
  RestElement: vars,
  ArrowFunctionExpression: \parameters body -> {
    referencing $ referenced (vars $ body) - referenced (mergeAll $ vars <$> parameters)
  },
  BlockExpression: \statements result -> {
    {declared, referenced} = reduce merge (vars result) (vars <$> statements);
    referencing $ referenced - declared
  },
  BlockStatement: \statements -> {
    {declared, referenced} = mergeAll (vars <$> statements);
    referencing $ referenced - declared
  },
  DoBlockExpression: \operations result -> referencing {
    reduceRight (\names -> match Node {
      FunctionDeclaration:    \name parameters body -> names | referenced (vars body) - referenced (mergeAll $ vars <$> parameters),
      VariableDeclaration:      \pattern expression -> referenced (vars pattern) - names | referenced (vars expression),  ;; x <- f x;
      ArrowAssignmentStatement: \pattern expression -> referenced (vars pattern) - names | referenced (vars expression),  ;; x = f x;
      ExpressionStatement:              \expression -> names | referenced (vars expression),
    }) (referenced $ vars result) operations
  },
  UnaryExpression: const vars,
  CompositionExpression: \left right -> vars left `merge` vars right,
  InfixCallExpression: \operator left right -> vars operator `merge` vars left `merge` vars right,
  BinaryExpression: \operator left right -> vars left `merge` vars right,
  ConcatenationExpression: \left right -> vars left `merge` vars right,
  MapExpression: \left right -> vars left `merge` vars right,
  BindExpression: \left right -> vars left `merge` vars right,
  LogicalExpression: \operator left right -> vars left `merge` vars right,
  ConditionalExpression: \predicate consequent alternative -> vars predicate `merge` vars consequent `merge` (maybe emptyVariables vars alternative),
  SwitchExpression: \discriminant cases -> mergeAll $ vars <$> [discriminant, ...cases],
  SwitchCase: \predicates consequent -> mergeAll $ vars <$> [...predicates, consequent],
  PipeExpression: \head body -> vars head `merge` vars body,
  CallExpression: \callee arguments -> mergeAll $ vars <$> [callee, ...arguments],
  ImportDeclaration: const $ mergeAll . map vars,
  ImportAllDeclaration: \source default hiding -> emptyVariables,
  ImportDefaultSpecifier: declaring . referenced . vars,
  ImportSpecifier: const $ declaring . referenced . vars,
  ImportNamespaceSpecifier: declaring . referenced . vars,
  ExportNamedDeclaration: mergeAll . map vars,
  ExportDefaultDeclaration: vars,
  ExportSpecifier: const . vars,
  VariableDeclaration: \pattern expression -> {
    declared = referenced $ vars pattern;
    variables declared $ referenced (vars expression) - declared
  },
  FunctionDeclaration: \name parameters body -> {
    declared = of Set name;
    variables declared $ referenced (vars body) - referenced (mergeAll $ vars <$> parameters) - declared
  },
  ExpressionStatement: vars,
  Module: \imports exports statements -> mergeAll $ vars <$> imports <> exports <> statements,
  DataTypeDeclaration: const . declaring . of Set,
};

;; flip f y x -> f x y
applyFlip = transform {
  CallExpression: \callee3 arguments3 -> {
    match' Node (const $ CallExpression callee3 arguments3) {
      CallExpression: \callee2 arguments2 -> {
        match' Node (const $ CallExpression (CallExpression callee2 arguments2) arguments3) {
          CallExpression: \callee1 arguments1 -> {
            match' Node (const $ CallExpression (CallExpression (CallExpression callee1 arguments1) arguments2) arguments3) {
              Identifier: \name -> {
                if name == "flip" and arguments1.length == 1
                then CallExpression (CallExpression arguments1[0] arguments3) arguments2
                else CallExpression (CallExpression (CallExpression (Identifier name) arguments1) arguments2) arguments3
              }
            } callee1
          }
        } callee2
      }
    } callee3
  }
};

removeUnreferencedPreludeFunctions module = {
  {declared, referenced} = vars module;
  unreferenced = declared - referenced;
  unnecessary = unreferenced ^ preludeNames;
  statements = reject (match' Node (const false) {VariableDeclaration: \{name} _ -> unnecessary has name}) module.statements;
  if statements.length == module.statements.length
  then module
  else removeUnreferencedPreludeFunctions (Module module.imports module.exports statements)
};

rewriteModule module namesExportedFrom = {
  {declared, referenced} = vars module;
  undeclared = referenced - declared;
  imports = Future.parallel 16 $ rewriteImportDeclaration undeclared namesExportedFrom <$> module.imports;
  withImports module = {
    ;; desugar first to simplify renaming
    module' = rewriteNode module;
    ;; create renaming function based on variable and function declarations
    rename = reduce (\rename -> match Node {
      DataTypeDeclaration: const $ const rename,
      VariableDeclaration: \pattern expression -> updateRenamerFromPattern rename pattern,
      FunctionDeclaration: \name parameters body -> updateRenamerFromPattern rename $ Identifier name,
      ExpressionStatement: const rename,
    }) id module'.statements;
    ;; wrap renaming function based on import declarations
    rename' = reduce (\rename -> match Node {
      ImportSpecifier: \imported local name -> if name == imported.name then local.name else rename name,
      ImportNamespaceSpecifier: updateRenamerFromPattern rename,
      ImportDefaultSpecifier: updateRenamerFromPattern rename,
    }) rename $ module'.imports >>= (.specifiers);
    ;; rename identifiers
    {imports, exports, statements} = applyFlip $ renameIdentifiers rename' module';
    ;; insert prelude
    prelude = (\[name, value] -> VariableDeclaration (Identifier name) value) <$> Object.entries Prelude;
    ;; remove unreferenced prelude functions
    module'' = removeUnreferencedPreludeFunctions $ Module imports exports $ prelude <> statements;
    {declared, referenced} = vars module'';
    unreferenced = declared - referenced;
    undeclared = referenced - declared - globals - construct Set [["CasesNotExhaustive", "DivisionByZero", "import", "console", "fetch"]];
    if unreferenced.size > 0 then (unreferenced % Array.from % .join [", "] % concat "unreferenced: " % console.error);
    if undeclared.size   > 0 then (undeclared   % Array.from % .join [", "] % concat "undeclared: "   % console.error);
    module''
  };
  (\imports -> withImports $ Module imports module.exports module.statements) <$> imports
};

rewriteImportAllDeclaration undeclared namesExportedFrom source default hiding = {
  namesExported = construct Set [
    if .endsWith [".serif"] source.value then namesExportedFrom source.value
    else Object.keys <$> Future.attemptP \() -> import source.value
  ];
  namesHidden = construct Set [(.name) <$> hiding];
  namesHiddenNeedlessly = namesHidden - namesExported;
  if namesHiddenNeedlessly.size > 0 then {
    Future.reject $ Error {
      """import * from "${
        source.value
      }" hiding {${
        .join [", "] $ namesHidden
      }};\n\n${
        format.list $ Array.from namesHiddenNeedlessly
      } ${
        if namesHiddenNeedlessly.size == 1 then "is" else "are"
      } not exported so need not be hidden.\n"""
    }
  } else {
    namesExported - namesHidden ^ undeclared
    % Array.from
    % map (\name -> ImportSpecifier (Identifier name)
                                    (Identifier $ if preludeNames has name then "$" + name else name))
    % maybe id (concat . Array.of) default
    % ImportDeclaration source
    % Future.resolve
  }
};

rewriteImportDeclaration undeclared namesExportedFrom = {
  match Node {
    ImportDeclaration: \source specifiers -> Future.resolve $ ImportDeclaration source specifiers,
    ImportAllDeclaration: rewriteImportAllDeclaration undeclared namesExportedFrom,
  }
};

#Object         = Identifier "Object";
#Symbol         = Identifier "Symbol";
#args           = Identifier "args";
#cases          = Identifier "cases";
#default        = Identifier "default";
#dollar         = Identifier "$";  ;; cannot cause shadowing as $ is not a valid Serif identifier
#target         = Identifier "target";

'apply          = StringLiteral "apply";
'for            = StringLiteral "for";
'has            = StringLiteral "has";
'hasOwn         = StringLiteral "hasOwn";
'match          = StringLiteral "match";
'tag            = StringLiteral "tag";

rewriteNode = transform {
  PropertyAccessor: \{name} -> {
    rewriteNode $ ArrowFunctionExpression [#dollar] $ MemberExpression #dollar $ StringLiteral name
  },
  BlockExpression: \statements result -> {
    if statements == []
    then rewriteNode result
    else BlockExpression (rewriteNode <$> statements) (rewriteNode result)
  },
  DoBlockExpression: \operations result -> {
    rewriteNode $ reduceRight (\result -> match Node {
      ArrowAssignmentStatement: \pattern expression -> {
        CallExpression (CallExpression (Identifier "chain") [ArrowFunctionExpression [pattern] result]) [expression]
      },
      VariableDeclaration: \pattern expression -> {
        CallExpression (ArrowFunctionExpression [pattern] result) [expression]
      },
      FunctionDeclaration: \name parameters body -> {
        CallExpression (ArrowFunctionExpression [Identifier name] result) [
          reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
        ]
      },
      ExpressionStatement: \expression -> {
        BlockExpression [ExpressionStatement expression] result
      },
    }) result operations
  },
  CompositionExpression: \left right -> {
    ;; Original expression: f . g . h
    ;;
    ;; Representation:   o
    ;;                  / \
    ;;                 f   o
    ;;                    / \
    ;;                   g   h
    ;;
    ;; Rewritten expression: \x -> f (g (h x))
    recur = match' Node (flip CallExpression [#dollar]) {
      CompositionExpression: \left right -> CallExpression left [recur right],
    };
    rewriteNode $ ArrowFunctionExpression [#dollar] $ recur $ CompositionExpression left right
  },
  InfixCallExpression: \operator left right -> {
    rewriteNode $ CallExpression (CallExpression operator [left]) [right]
  },
  BinaryExpression: \operator left right -> {
    switch operator
    when "=="  then rewriteNode $ CallExpression (CallExpression (Identifier "equals") [right]) [left]
    when "!="  then rewriteNode $ CallExpression (Identifier "not") [BinaryExpression "==" left right]
    when "has" then rewriteNode $ CallExpression (MemberExpression left 'has) [right]
    when "in"  then rewriteNode $ CallExpression (CallExpression (Identifier "contains") [left]) [right]
    when "^"   then rewriteNode $ CallExpression (CallExpression (Identifier "XOR") [right]) [left]
    when "|"   then rewriteNode $ CallExpression (CallExpression (Identifier "OR") [right]) [left]
    when "-"   then rewriteNode $ CallExpression (CallExpression (Identifier "subtract") [right]) [left]
    else BinaryExpression operator (rewriteNode left) (rewriteNode right)
  },
  ConcatenationExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "concat") [left]) [right]
  },
  MapExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "map") [left]) [right]
  },
  BindExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "chain") [right]) [left]
  },
  PipeExpression: \head body -> {
    rewriteNode $ CallExpression body [head]
  },
  MethodCallExpression: \name -> {
    rewriteNode {
      ArrowFunctionExpression [#args] {
        ArrowFunctionExpression [#target] {
          CallExpression (MemberExpression (MemberExpression #target $ StringLiteral name) 'apply) [#target, #args]
        }
      }
    }
  },
  CallExpression: flip \arguments -> {
    match' Node (\callee -> CallExpression (rewriteNode callee) (rewriteNode <$> arguments)) {
      PropertyAccessor: rewriteNode . MemberExpression arguments[0] . StringLiteral . (.name),
    }
  },
  DataTypeDeclaration: \name constructors -> {
    @tag = CallExpression (MemberExpression #Symbol 'for) ['tag];
    @match = CallExpression (MemberExpression #Symbol 'for) ['match];
    constructors
    % map (\{name, parameters} -> Property (StringLiteral name) $ reduceRight
        (\body parameter -> ArrowFunctionExpression [Identifier parameter] body)
        (parameters
         % map (\name -> Property (StringLiteral name) (Identifier name))
         % concat [Property @tag (StringLiteral name)]
         % ObjectExpression)
        parameters
      )
    % concat [Property @match {
        #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] name;
        case {name, parameters} = {
          SwitchCase [Just $ StringLiteral name] {
            reduce (\callee name -> CallExpression callee [MemberExpression #member $ StringLiteral name])
                   (MemberExpression #cases $ StringLiteral name)
                   parameters
          }
        };
        ArrowFunctionExpression [#default] {
          ArrowFunctionExpression [#cases] {
            ArrowFunctionExpression [#member] {
              ConditionalExpression
                (CallExpression (MemberExpression #Object 'hasOwn) [#cases, MemberExpression #member @tag])
                (SwitchExpression (MemberExpression #member @tag) (case <$> constructors))
                (Just $ CallExpression #default [#member])
            }
          }
        }
      }]
    % ObjectExpression
    % VariableDeclaration $ Identifier name
    % rewriteNode
  },
};

updateRenamerFromPattern rename node = flip (match Node) node {
  Identifier: \name -> {
    if preludeNames has name
    then \this -> if this == name then "$" + this else rename this
    else rename
  },
  ArrayPattern:   reduce updateRenamerFromPattern rename,
  ObjectPattern:  reduce updateRenamerFromPattern rename,
  Property:       const (updateRenamerFromPattern rename),
  RestElement:    updateRenamerFromPattern rename,
  Elision:        rename,
};

renameIdentifiers rename = transform {
  Identifier: Identifier . rename,
  ImportSpecifier: \imported local -> ImportSpecifier imported (renameIdentifiers rename local),
  ExportSpecifier: \local exported -> ExportSpecifier (renameIdentifiers rename local) exported,
  FunctionDeclaration: \name parameters body -> {
    FunctionDeclaration (rename name)
                        (renameIdentifiers rename <$> parameters)
                        (renameIdentifiers rename body)
  },
};
