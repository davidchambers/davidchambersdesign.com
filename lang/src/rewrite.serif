import * from "./types.serif";

export default {imports, exports, statements} => {
  Module {
    imports: imports,
    exports: rewrite <$> exports,
    statements: rewrite <$> statements,
  }
};

rewrite node = {
  switch node.type
  when "TemplateLiteral" then {
    TemplateLiteral node.quasis $ rewrite <$> node.expressions
  }
  when "MemberExpression" then {
    MemberExpression (rewrite node.object) (rewrite node.property)
  }
  when "ArrayExpression" then {
    ArrayExpression $ rewrite <$> node.elements
  }
  when "ObjectExpression" then {
    ObjectExpression $ rewrite <$> node.properties
  }
  when "ArrowFunctionExpression" then {
    ArrowFunctionExpression (rewrite <$> node.parameters) (rewrite node.body)
  }
  when "PropertyAccessor" then {
    param = Identifier "x";
    ArrowFunctionExpression [param] $
      MemberExpression param $ StringLiteral node.identifier.name
  }
  when "BlockExpression" then {
    if node.statements.length == 1 and node.statements[0].type == "ExpressionStatement" then {
      rewrite node.statements[0].expression
    } else {
      BlockExpression $ rewrite <$> node.statements
    }
  }
  when "UnaryExpression" then {
    UnaryExpression node.operator (rewrite node.argument)
  }
  when "BinaryExpression" then {
    BinaryExpression node.operator (rewrite node.left) (rewrite node.right)
  }
  when "MapExpression" then {
    CallExpression (CallExpression (prelude "map")
                                   [rewrite node.left])
                   [rewrite node.right]
  }
  when "BindExpression" then {
    CallExpression (CallExpression (prelude "chain")
                                   [rewrite node.right])
                   [rewrite node.left]
  }
  when "LogicalExpression" then {
    LogicalExpression node.operator (rewrite node.left) (rewrite node.right)
  }
  when "ConditionalExpression" then {
    ConditionalExpression (rewrite node.predicate)
                          (rewrite node.consequent)
                          (rewrite node.alternative)
  }
  when "SwitchExpression" then {
    SwitchExpression (rewrite node.discriminant)
                     (rewrite <$> node.cases)
                     (if node.default == null then null else rewrite node.default)
  }
  when "SwitchCase" then {
    SwitchCase (rewrite <$> node.predicates) (rewrite node.consequent)
  }
  when "PipeExpression" then {
    rewrite $ CallExpression node.body [node.head]
  }
  when "CallExpression" then {
    CallExpression (rewrite node.callee) (rewrite <$> node.arguments)
  }
  when "VariableDeclaration" then {
    VariableDeclaration (rewrite node.pattern) (rewrite node.expression)
  }
  when "FunctionDeclaration" then {
    FunctionDeclaration node.name (rewrite <$> node.parameters) (rewrite node.body)
  }
  when "ExpressionStatement" then {
    ExpressionStatement $ rewrite node.expression
  }
  when "ArrayPattern" then {
    ArrayPattern $ rewrite <$> node.elements
  }
  when "ObjectPattern" then {
    ObjectPattern $ rewrite <$> node.properties
  }
  when "SpreadElement" then {
    SpreadElement $ rewrite node.argument
  }
  when "RestElement" then {
    RestElement $ rewrite node.argument
  }
  when "Property" then {
    Property (rewrite node.key) (rewrite node.value)
  }
  when "ExportDefaultDeclaration" then {
    ExportDefaultDeclaration $ rewrite node.declaration
  }
  when "ImportExpression" then {
    ImportExpression $ rewrite node.source
  }
  else {
    node
  }
};

prelude name = {
  MemberExpression (Identifier "Prelude")
                   (StringLiteral name)
};
