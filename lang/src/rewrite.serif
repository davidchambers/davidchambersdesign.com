import * as Future from "fluture";

import * from "./Maybe.serif";
import Node, * from "./Node.serif";
import * as format from "./format.serif";
import globals from "./globals.serif";
import parallel from "./parallel.serif";
import Prelude from "./prelude.serif";

export default rewriteModule;

preludeNames = construct Set [Object.keys Prelude];

variables declared referenced = {declared, referenced};
declaring   names = variables names (empty Set);
referencing names = variables (empty Set) names;
emptyVariables    = variables (empty Set) (empty Set);

referenced = (.referenced);

merge lhs rhs = {
  declared:   lhs.declared   | rhs.declared,
  referenced: lhs.referenced | rhs.referenced,
};

mergeAll = reduce merge emptyVariables;

vars = foldRec {
  ArrayExpression:                                     \varsProperties -> mergeAll varsProperties,
  ArrayPattern:                                        \varsProperties -> mergeAll varsProperties,
  ArrowFunctionExpression:                    \varsParameters varsBody -> referencing $ referenced varsBody - referenced (mergeAll varsParameters),
  Block:                                    \varsStatements varsResult -> { {declared, referenced} = maybe id merge varsResult $ mergeAll varsStatements; referencing $ referenced - declared },
  BooleanLiteral:                                               \value -> emptyVariables,
  CallExpression:                            \varsCallee varsArguments -> varsCallee `merge` mergeAll varsArguments,
  ConditionalExpression: \varsPredicate varsConsequent varsAlternative -> varsPredicate `merge` varsConsequent `merge` fromMaybe emptyVariables varsAlternative,
  ExportDefaultDeclaration:                           \varsDeclaration -> varsDeclaration,
  ExportNamedDeclaration:                              \varsSpecifiers -> mergeAll varsSpecifiers,
  ExportSpecifier:                                 \varsLocal exported -> varsLocal,
  ExpressionStatement:                                 \varsExpression -> varsExpression,
  Identifier:                                                    \name -> referencing $ of Set name,
  ImportAllSpecifier:                                          \hiding -> emptyVariables,
  ImportDeclaration:                            \source varsSpecifiers -> mergeAll varsSpecifiers,
  ImportDefaultSpecifier:                                   \varsLocal -> declaring $ referenced varsLocal,
  ImportNamespaceSpecifier:                                 \varsLocal -> declaring $ referenced varsLocal,
  ImportSpecifier:                                 \imported varsLocal -> declaring $ referenced varsLocal,
  InfixExpression:                        \operator varsLeft varsRight -> varsLeft `merge` varsRight,
  MemberExpression:                           \varsObject varsProperty -> varsObject `merge` varsProperty,
  Module:                      \varsImports varsExports varsStatements -> mergeAll varsImports `merge` mergeAll varsExports `merge` mergeAll varsStatements,
  NullLiteral:                                                            emptyVariables,
  NumberLiteral:                                                \value -> emptyVariables,
  ObjectExpression:                                    \varsProperties -> mergeAll varsProperties,
  ObjectPattern:                                       \varsProperties -> mergeAll varsProperties,
  PrefixExpression:                              \operator varsOperand -> varsOperand,
  Property:                                         \varsKey varsValue -> varsKey `merge` varsValue,
  RestElement:                                           \varsArgument -> varsArgument,
  SpreadElement:                                         \varsArgument -> varsArgument,
  StringLiteral:                                                \value -> emptyVariables,
  SwitchCase:                           \varsPredicates varsConsequent -> mergeAll (varsPredicates >>= fromMaybe []) `merge` varsConsequent,
  SwitchExpression:                        \varsDiscriminant varsCases -> varsDiscriminant `merge` mergeAll varsCases,
  TemplateLiteral:                             \quasis varsExpressions -> mergeAll varsExpressions,
  VariableDeclaration:                     \varsPattern varsExpression -> { declared = referenced varsPattern; variables declared $ referenced varsExpression - declared },
};

removeUnreferencedPreludeFunctions module = {
  {declared, referenced} = vars module;
  unreferenced = declared - referenced;
  unnecessary = unreferenced & preludeNames;
  statements = reject (match' Node (const false) {VariableDeclaration: \{name} _ -> unnecessary has name}) module.statements;
  if statements.length == module.statements.length
  then module
  else removeUnreferencedPreludeFunctions $ Module module.imports module.exports statements
};

rewriteModule module namesExportedFrom = do {
  ;; desugar first to simplify subsequent steps
  module = rewriteNode module;
  {imports, exports, statements} = module;
  {declared, referenced} = vars module;
  imports <- parallel $ (<$> imports) $ match Node {
    ImportDeclaration: \source specifiers -> {
      specifiers
      % map (rewriteImportAllSpecifier (referenced - declared) namesExportedFrom source)
      % parallel
      % map (ImportDeclaration source . join)
    },
  };
  ;; create renaming function based on variable and function declarations
  rename = reduce (\rename -> match Node {
    DataTypeDeclaration: const $ const rename,
    VariableDeclaration: \pattern expression -> updateRenamerFromPattern rename pattern,
    ExpressionStatement: const rename,
  }) id statements;
  ;; wrap renaming function based on import declarations
  rename = reduce (\rename -> match Node {
    ImportSpecifier: \imported local name -> if name == imported.name then local.name else rename name,
    ImportNamespaceSpecifier: updateRenamerFromPattern rename,
    ImportDefaultSpecifier: updateRenamerFromPattern rename,
  }) rename $ imports >>= (.specifiers);
  ;; rename identifiers
  {imports, exports, statements} = renameIdentifiers rename $ Module imports exports statements;
  ;; insert prelude
  prelude = (\[name, value] -> VariableDeclaration (Identifier name) value) <$> Object.entries Prelude;
  ;; remove unreferenced prelude functions
  module = removeUnreferencedPreludeFunctions $ Module imports exports $ prelude <> statements;
  {declared, referenced} = vars module;
  unreferenced = declared - referenced;
  undeclared = referenced - declared - globals - construct Set [["CasesNotExhaustive", "DivisionByZero", "import", "console", "fetch"]];
  if unreferenced.size > 0 then (unreferenced % Array.from % .join [", "] % concat "unreferenced: " % console.error);
  if undeclared.size   > 0 then (undeclared   % Array.from % .join [", "] % concat "undeclared: "   % console.error);
  Future.resolve module
};

rewriteImportAllSpecifier undeclared namesExportedFrom source = {
  match' Node (Future.resolve . Array.of) {
    ImportAllSpecifier: \hiding -> do {
      namesExported <- {
        if .endsWith [".serif"] source.value
        then Future.resolve $ namesExportedFrom source.value
        else Object.keys <$> Future.attemptP \() -> import source.value
      };
      namesExported = construct Set [namesExported];
      namesHidden = construct Set [(.name) <$> hiding];
      namesHiddenNeedlessly = namesHidden - namesExported;
      if namesHiddenNeedlessly.size > 0 then {
        Future.reject $ Error {
          (format.list $ Array.from namesHiddenNeedlessly)
          + " "
          + (if namesHiddenNeedlessly.size == 1 then "is" else "are")
          + " not exported from "
          + source.value
          + " so need not be hidden"
        }
      } else {
        namesExported - namesHidden & undeclared
        % Array.from  ;; TODO: sort
        % map (\name -> ImportSpecifier (Identifier name)
                                        (Identifier $ if preludeNames has name then "$" + name else name))
        % Future.resolve
      }
    }
  }
};

#$              = Identifier "$";  ;; cannot cause shadowing as $ is not a valid Serif identifier
#$lhs           = Identifier "$lhs";  ;; cannot cause shadowing as $lhs is not a valid Serif identifier
#$rhs           = Identifier "$rhs";  ;; cannot cause shadowing as $rhs is not a valid Serif identifier
#Object         = Identifier "Object";
#Symbol         = Identifier "Symbol";
#args           = Identifier "args";
#cases          = Identifier "cases";
#default        = Identifier "default";
#target         = Identifier "target";

'apply          = StringLiteral "apply";
'for            = StringLiteral "for";
'has            = StringLiteral "has";
'hasOwn         = StringLiteral "hasOwn";
'match          = StringLiteral "match";
'tag            = StringLiteral "tag";

@match          = CallExpression (MemberExpression #Symbol 'for) ['match];
@tag            = CallExpression (MemberExpression #Symbol 'for) ['tag];

rewriteNode = transform {
  PropertyAccessor: \{name} -> {
    rewriteNode $ ArrowFunctionExpression [#$] $ MemberExpression #$ $ StringLiteral name
  },
  LeftSection: \operator lhs -> {
    rewriteNode $ ArrowFunctionExpression [#$rhs] $ InfixExpression operator lhs #$rhs
  },
  RightSection: \operator rhs -> {
    rewriteNode $ ArrowFunctionExpression [#$lhs] $ InfixExpression operator #$lhs rhs
  },
  EmptySection: \operator -> {
    rewriteNode $ ArrowFunctionExpression [#$lhs] $ ArrowFunctionExpression [#$rhs] $ InfixExpression operator #$lhs #$rhs
  },
  Block: \statements result -> {
    if statements == []
    then rewriteNode $ fromJust! result
    else Block (rewriteNode <$> statements) (rewriteNode <$> result)
  },
  DoBlockExpression: \operations result -> {
    rewriteNode $ reduceRight (\result -> match Node {
      ArrowAssignmentStatement: \pattern expression -> {
        CallExpression (CallExpression (Identifier "chain") [ArrowFunctionExpression [pattern] result]) [expression]
      },
      VariableDeclaration: \pattern expression -> {
        CallExpression (ArrowFunctionExpression [pattern] result) [expression]
      },
      FunctionDeclaration: \name parameters body -> {
        CallExpression (ArrowFunctionExpression [Identifier name] result) [
          reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
        ]
      },
      ExpressionStatement: \expression -> {
        Block [ExpressionStatement expression] $ Just result
      },
    }) result operations
  },
  InfixCallExpression: \operator left right -> {
    rewriteNode $ CallExpression (CallExpression operator [left]) [right]
  },
  InfixExpression: \operator lhs rhs -> {
    switch operator
    when "."   then rewriteNode $ CallExpression (CallExpression (Identifier "compose" ) [lhs]) [rhs]
    when "-"   then rewriteNode $ CallExpression (CallExpression (Identifier "subtract") [rhs]) [lhs]
    when "<>"  then rewriteNode $ CallExpression (CallExpression (Identifier "concat"  ) [lhs]) [rhs]
    when "has" then rewriteNode $ CallExpression                    (MemberExpression lhs 'has) [rhs]
    when "in"  then rewriteNode $ CallExpression (CallExpression (Identifier "contains") [lhs]) [rhs]
    when "=="  then rewriteNode $ CallExpression (CallExpression (Identifier "equals"  ) [rhs]) [lhs]
    when "!="  then rewriteNode $ CallExpression    (Identifier "not") [InfixExpression "==" lhs rhs]
    when "<$>" then rewriteNode $ CallExpression (CallExpression (Identifier "map"     ) [lhs]) [rhs]
    when "&"   then rewriteNode $ CallExpression (CallExpression (Identifier "AND"     ) [rhs]) [lhs]
    when "^"   then rewriteNode $ CallExpression (CallExpression (Identifier "XOR"     ) [rhs]) [lhs]
    when "|"   then rewriteNode $ CallExpression (CallExpression (Identifier "OR"      ) [rhs]) [lhs]
    when ">>=" then rewriteNode $ CallExpression (CallExpression (Identifier "chain"   ) [rhs]) [lhs]
    when "$"   then rewriteNode $ CallExpression lhs [rhs]
    when "%"   then rewriteNode $ CallExpression rhs [lhs]
    else InfixExpression operator (rewriteNode lhs) (rewriteNode rhs)
  },
  MethodCallExpression: \name -> {
    rewriteNode {
      ArrowFunctionExpression [#args] {
        ArrowFunctionExpression [#target] {
          CallExpression (MemberExpression (MemberExpression #target $ StringLiteral name) 'apply) [#target, #args]
        }
      }
    }
  },
  CallExpression: flip \arguments -> {
    match' Node (\callee -> CallExpression (rewriteNode callee) (rewriteNode <$> arguments)) {
      PropertyAccessor: rewriteNode . MemberExpression arguments[0] . StringLiteral . (.name),
    }
  },
  FunctionDeclaration: \name parameters body -> rewriteNode {
    VariableDeclaration (Identifier name)
                        (reduceRight (flip $ ArrowFunctionExpression . Array.of) body parameters)
  },
  DataTypeDeclaration: \identifier constructors -> rewriteNode {
    pattern = {
      constructors
      % map (.identifier)
      % prepend identifier
      % map (join Property)
      % ObjectPattern
    };
    VariableDeclaration pattern {
      variableDeclarationFromConstructor = match Node {
        DataConstructorDefinition: \identifier parameters -> {
          VariableDeclaration identifier $ reduceRight
            (\body parameter -> ArrowFunctionExpression [parameter] body)
            (parameters
             % map (\parameter -> Property (StringLiteral parameter.name) parameter)
             % prepend (Property @tag (StringLiteral identifier.name))
             % ObjectExpression)
            parameters
        },
      };
      variableDeclarations = variableDeclarationFromConstructor <$> constructors;
      propertyFromConstructor = match Node {
        DataConstructorDefinition: \identifier parameters -> {
          Property (StringLiteral identifier.name) identifier
        },
      };
      constructorProperties = propertyFromConstructor <$> constructors;
      matchProperty = Property @match {
        #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] identifier.name;
        case {identifier, parameters} = {
          SwitchCase [Just $ StringLiteral identifier.name] {
            reduce (\callee parameter -> CallExpression callee [MemberExpression #member $ StringLiteral parameter.name])
                   (MemberExpression #cases $ StringLiteral identifier.name)
                   parameters
          }
        };
        ArrowFunctionExpression [#default] {
          ArrowFunctionExpression [#cases] {
            ArrowFunctionExpression [#member] {
              ConditionalExpression
                (CallExpression (MemberExpression #Object 'hasOwn) [#cases, MemberExpression #member @tag])
                (SwitchExpression (MemberExpression #member @tag) (case <$> constructors))
                (Just $ CallExpression #default [#member])
            }
          }
        }
      };
      Block variableDeclarations $ Just {
        ObjectExpression [
          Property (StringLiteral identifier.name) $ ObjectExpression [...constructorProperties, matchProperty],
          ...constructorProperties,
        ]
      }
    }
  },
};

updateRenamerFromPattern rename = match Node {
  Identifier:          \name -> if preludeNames has name then \this -> if this == name then "$" + this else rename this else rename,
  ArrayPattern:    \elements -> reduce updateRenamerFromPattern rename elements,
  ObjectPattern: \properties -> reduce updateRenamerFromPattern rename properties,
  Property:       \key value -> updateRenamerFromPattern rename value,
  RestElement:     \argument -> updateRenamerFromPattern rename argument,
  Elision:                      rename,
};

renameIdentifiers rename = transform {
  Identifier: Identifier . rename,
  ImportSpecifier: \imported local -> ImportSpecifier imported (renameIdentifiers rename local),
  ExportSpecifier: \local exported -> ExportSpecifier (renameIdentifiers rename local) exported,
};
