import * as Future from "fluture";

import Maybe from "./Maybe.serif";
import Node from "./Node.serif";
import * as format from "./format.serif";
import globals from "./globals.serif";
import Prelude from "./prelude.serif";

export default rewriteModule;

{
  NullLiteral,
  BooleanLiteral,
  NumberLiteral,
  StringLiteral,
  TemplateLiteral,
  MemberExpression,
  Identifier,
  SpreadElement,
  ArrayExpression,
  Elision,
  Property,
  ObjectExpression,
  ArrayPattern,
  ObjectPattern,
  RestElement,
  ArrowFunctionExpression,
  BlockExpression,
  BlockStatement,
  UnaryExpression,
  CompositionExpression,
  BinaryExpression,
  LogicalExpression,
  ConditionalExpression,
  SwitchExpression,
  SwitchCase,
  CallExpression,
  ImportDeclaration,
  ImportSpecifier,
  ImportDefaultSpecifier,
  ImportNamespaceSpecifier,
  ExportDefaultDeclaration,
  ExportNamedDeclaration,
  ExportSpecifier,
  VariableDeclaration,
  FunctionDeclaration,
  ExpressionStatement,
  Module,
} = Node;

preludeNames = construct Set [Object.keys Prelude];

variables declared referenced = {declared, referenced};
declaring   names = variables names (empty Set);
referencing names = variables (empty Set) names;
emptyVariables    = variables (empty Set) (empty Set);

referenced = (.referenced);

merge lhs rhs = {
  declared:   lhs.declared   | rhs.declared,
  referenced: lhs.referenced | rhs.referenced,
};

mergeAll = reduce merge emptyVariables;

vars node = flip (match' Node $ const emptyVariables) node {
  TemplateLiteral: const $ mergeAll . map vars,
  MemberExpression: \object property -> vars object `merge` vars property,
  Identifier: referencing . of Set,
  SpreadElement: vars,
  ArrayExpression: mergeAll . map vars,
  Property: \key value -> vars key `merge` vars value,
  ObjectExpression: mergeAll . map vars,
  ArrayPattern: mergeAll . map vars,
  ObjectPattern: mergeAll . map vars,
  RestElement: vars,
  ArrowFunctionExpression: \parameters body -> {
    referencing $ referenced (vars $ body) - referenced (mergeAll $ vars <$> parameters)
  },
  BlockExpression: \statements result -> {
    {declared, referenced} = reduce merge (vars result) (vars <$> statements);
    referencing $ referenced - declared
  },
  BlockStatement: \statements -> {
    {declared, referenced} = mergeAll (vars <$> statements);
    referencing $ referenced - declared
  },
  DoBlockExpression: \operations result -> referencing {
    reduceRight (\names -> match Node {
      FunctionDeclaration:    \name parameters body -> names | referenced (vars body) - referenced (mergeAll $ vars <$> parameters),
      VariableDeclaration:      \pattern expression -> referenced (vars pattern) - names | referenced (vars expression),  ;; x <- f x;
      ArrowAssignmentStatement: \pattern expression -> referenced (vars pattern) - names | referenced (vars expression),  ;; x = f x;
      ExpressionStatement:              \expression -> names | referenced (vars expression),
    }) (referenced $ vars result) operations
  },
  UnaryExpression: const vars,
  CompositionExpression: \left right -> vars left `merge` vars right,
  InfixCallExpression: \operator left right -> vars operator `merge` vars left `merge` vars right,
  BinaryExpression: \operator left right -> vars left `merge` vars right,
  ConcatenationExpression: \left right -> vars left `merge` vars right,
  MapExpression: \left right -> vars left `merge` vars right,
  BindExpression: \left right -> vars left `merge` vars right,
  LogicalExpression: \operator left right -> vars left `merge` vars right,
  ConditionalExpression: \predicate consequent alternative -> vars predicate `merge` vars consequent `merge` (Maybe.maybe emptyVariables vars alternative),
  SwitchExpression: \discriminant cases -> mergeAll $ vars <$> [discriminant, ...cases],
  SwitchCase: \predicates consequent -> mergeAll $ vars <$> [...predicates, consequent],
  PipeExpression: \head body -> vars head `merge` vars body,
  CallExpression: \callee arguments -> mergeAll $ vars <$> [callee, ...arguments],
  ImportDeclaration: const $ mergeAll . map vars,
  ImportAllDeclaration: const $ const $ emptyVariables,
  ImportDefaultSpecifier: declaring . referenced . vars,
  ImportSpecifier: const $ declaring . referenced . vars,
  ImportNamespaceSpecifier: declaring . referenced . vars,
  ExportNamedDeclaration: mergeAll . map vars,
  ExportDefaultDeclaration: vars,
  ExportSpecifier: const . vars,
  VariableDeclaration: \pattern expression -> {
    declared = referenced $ vars pattern;
    variables declared $ referenced (vars expression) - declared
  },
  FunctionDeclaration: \name parameters body -> {
    declared = of Set name;
    variables declared $ referenced (vars body) - referenced (mergeAll $ vars <$> parameters) - declared
  },
  ExpressionStatement: vars,
  Module: \imports exports statements -> mergeAll $ vars <$> imports <> exports <> statements,
  DataTypeDeclaration: const . declaring . of Set,
};

removeUnreferencedPreludeFunctions module = {
  {declared, referenced} = vars module;
  unreferenced = declared - referenced;
  unnecessary = unreferenced ^ preludeNames;
  statements = reject (match' Node (const false) {VariableDeclaration: \{name} _ -> unnecessary has name}) module.statements;
  if statements.length == module.statements.length
  then module
  else removeUnreferencedPreludeFunctions (Module module.imports module.exports statements)
};

rewriteModule module namesExportedFrom = {
  {declared, referenced} = vars module;
  undeclared = referenced - declared;
  imports = Future.parallel 16 $ rewriteImportDeclaration undeclared namesExportedFrom <$> module.imports;
  withImports module = {
    ;; desugar first to simplify renaming
    module' = rewriteNode module;
    ;; create renaming function based on variable and function declarations
    rename = reduce (\rename -> match Node {
      DataTypeDeclaration: const $ const rename,
      VariableDeclaration: \pattern expression -> updateRenamerFromPattern rename pattern,
      FunctionDeclaration: \name parameters body -> updateRenamerFromPattern rename $ Identifier name,
      ExpressionStatement: const rename,
    }) id module'.statements;
    ;; wrap renaming function based on import declarations
    rename' = reduce (\rename -> match Node {
      ImportSpecifier: \imported local name -> if name == imported.name then local.name else rename name,
      ImportNamespaceSpecifier: updateRenamerFromPattern rename,
      ImportDefaultSpecifier: updateRenamerFromPattern rename,
    }) rename $ module'.imports >>= (.specifiers);
    ;; rename identifiers
    {imports, exports, statements} = renameIdentifiers rename' module';
    ;; insert prelude
    prelude = (\[name, value] -> VariableDeclaration (Identifier name) value) <$> Object.entries Prelude;
    ;; remove unreferenced prelude functions
    module'' = removeUnreferencedPreludeFunctions $ Module imports exports $ prelude <> statements;
    {declared, referenced} = vars module'';
    unreferenced = declared - referenced;
    undeclared = referenced - declared - globals - construct Set [["CasesNotExhaustive", "DivisionByZero", "import", "console", "fetch"]];
    if unreferenced.size > 0 then (unreferenced % Array.from % .join [", "] % concat "unreferenced: " % console.error);
    if undeclared.size   > 0 then (undeclared   % Array.from % .join [", "] % concat "undeclared: "   % console.error);
    module''
  };
  (\imports -> withImports $ Module imports module.exports module.statements) <$> imports
};

rewriteImportAllDeclaration undeclared namesExportedFrom source hiding = {
  namesExported = construct Set [
    if .endsWith [".serif"] source.value then namesExportedFrom source.value
    else Object.keys <$> Future.attemptP \() -> import source.value
  ];
  namesHidden = construct Set [(.name) <$> hiding];
  namesHiddenNeedlessly = namesHidden - namesExported;
  if namesHiddenNeedlessly.size > 0 then {
    Future.reject $ Error {
      """import * from "${
        source.value
      }" hiding {${
        .join [", "] $ namesHidden
      }};\n\n${
        format.list $ Array.from namesHiddenNeedlessly
      } ${
        if namesHiddenNeedlessly.size == 1 then "is" else "are"
      } not exported so need not be hidden.\n"""
    }
  } else {
    namesExported - namesHidden ^ undeclared
    % Array.from
    % map (\name -> ImportSpecifier (Identifier name)
                                    (Identifier $ if preludeNames has name then "$" + name else name))
    % ImportDeclaration source
    % Future.resolve
  }
};

rewriteImportDeclaration undeclared namesExportedFrom = {
  match Node {
    ImportDeclaration: \source specifiers -> Future.resolve $ ImportDeclaration source specifiers,
    ImportAllDeclaration: rewriteImportAllDeclaration undeclared namesExportedFrom,
  }
};

#Object         = Identifier "Object";
#Symbol         = Identifier "Symbol";
#args           = Identifier "args";
#cases          = Identifier "cases";
#default        = Identifier "default";
#dollar         = Identifier "$";  ;; cannot cause shadowing as $ is not a valid Serif identifier
#target         = Identifier "target";

'apply          = StringLiteral "apply";
'for            = StringLiteral "for";
'has            = StringLiteral "has";
'hasOwn         = StringLiteral "hasOwn";
'match          = StringLiteral "match";
'tag            = StringLiteral "tag";

rewriteNode node = flip (match' Node id) node {
  TemplateLiteral: \quasis expressions -> TemplateLiteral quasis (rewriteNode <$> expressions),
  MemberExpression: \object property -> MemberExpression (rewriteNode object) (rewriteNode property),
  ArrayExpression: ArrayExpression . map rewriteNode,
  ObjectExpression: ObjectExpression . map rewriteNode,
  ArrowFunctionExpression: \parameters body -> ArrowFunctionExpression (rewriteNode <$> parameters) (rewriteNode body),
  PropertyAccessor: \{name} -> rewriteNode $ ArrowFunctionExpression [#dollar] $ MemberExpression #dollar $ StringLiteral name,
  BlockExpression: \statements result -> if statements == [] then rewriteNode result else BlockExpression (rewriteNode <$> statements) (rewriteNode result),
  BlockStatement: BlockStatement . map rewriteNode,
  DoBlockExpression: \operations result -> {
    rewriteNode $ reduceRight (\result -> match Node {
      ArrowAssignmentStatement: \pattern expression -> {
        CallExpression (CallExpression (Identifier "chain") [ArrowFunctionExpression [pattern] result]) [expression]
      },
      VariableDeclaration: \pattern expression -> {
        CallExpression (ArrowFunctionExpression [pattern] result) [expression]
      },
      FunctionDeclaration: \name parameters body -> {
        CallExpression (ArrowFunctionExpression [Identifier name] result) [
          reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
        ]
      },
      ExpressionStatement: \expression -> {
        BlockExpression [ExpressionStatement expression] result
      },
    }) result operations
  },
  UnaryExpression: \operator -> UnaryExpression operator . rewriteNode,
  CompositionExpression: \left right -> {
    ;; Original expression: f . g . h
    ;;
    ;; Representation:   o
    ;;                  / \
    ;;                 f   o
    ;;                    / \
    ;;                   g   h
    ;;
    ;; Rewritten expression: \x -> f (g (h x))
    recur = match' Node (flip CallExpression [#dollar]) {
      CompositionExpression: \left right -> CallExpression left [recur right],
    };
    rewriteNode $ ArrowFunctionExpression [#dollar] $ recur $ CompositionExpression left right
  },
  InfixCallExpression: \operator left right -> {
    rewriteNode $ CallExpression (CallExpression operator [left]) [right]
  },
  BinaryExpression: \operator left right -> {
    switch operator
    when "=="  then rewriteNode $ CallExpression (CallExpression (Identifier "equals") [right]) [left]
    when "!="  then rewriteNode $ CallExpression (Identifier "not") [BinaryExpression "==" left right]
    when "has" then rewriteNode $ CallExpression (MemberExpression left 'has) [right]
    when "in"  then rewriteNode $ CallExpression (CallExpression (Identifier "contains") [left]) [right]
    when "^"   then rewriteNode $ CallExpression (CallExpression (Identifier "XOR") [right]) [left]
    when "|"   then rewriteNode $ CallExpression (CallExpression (Identifier "OR") [right]) [left]
    when "-"   then rewriteNode $ CallExpression (CallExpression (Identifier "subtract") [right]) [left]
    else BinaryExpression operator (rewriteNode left) (rewriteNode right)
  },
  ConcatenationExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "concat") [left]) [right]
  },
  MapExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "map") [left]) [right]
  },
  BindExpression: \left right -> {
    rewriteNode $ CallExpression (CallExpression (Identifier "chain") [right]) [left]
  },
  LogicalExpression: \operator left right -> {
    LogicalExpression operator (rewriteNode left) (rewriteNode right)
  },
  ConditionalExpression: \predicate consequent alternative -> {
    ConditionalExpression (rewriteNode predicate) (rewriteNode consequent) (rewriteNode <$> alternative)
  },
  SwitchExpression: \discriminant cases -> {
    SwitchExpression (rewriteNode discriminant) (rewriteNode <$> cases)
  },
  SwitchCase: \predicates consequent -> {
    SwitchCase (map rewriteNode <$> predicates) (rewriteNode consequent)
  },
  PipeExpression: \head body -> rewriteNode $ CallExpression body [head],
  MethodCallExpression: \name -> {
    rewriteNode {
      ArrowFunctionExpression [#args] {
        ArrowFunctionExpression [#target] {
          CallExpression (MemberExpression (MemberExpression #target $ StringLiteral name) 'apply) [#target, #args]
        }
      }
    }
  },
  CallExpression: flip \arguments -> {
    match' Node (\callee -> CallExpression (rewriteNode callee) (rewriteNode <$> arguments)) {
      PropertyAccessor: rewriteNode . MemberExpression arguments[0] . StringLiteral . (.name),
    }
  },
  VariableDeclaration: \pattern -> VariableDeclaration (rewriteNode pattern) . rewriteNode,
  FunctionDeclaration: \name parameters -> FunctionDeclaration name (rewriteNode <$> parameters) . rewriteNode,
  ExpressionStatement: ExpressionStatement . rewriteNode,
  ArrayPattern: ArrayPattern . map rewriteNode,
  ObjectPattern: ObjectPattern . map rewriteNode,
  SpreadElement: SpreadElement . rewriteNode,
  RestElement: RestElement . rewriteNode,
  Property: \key value -> Property (rewriteNode key) (rewriteNode value),
  ExportDefaultDeclaration: ExportDefaultDeclaration . rewriteNode,
  DataTypeDeclaration: \name constructors -> {
    @tag = CallExpression (MemberExpression #Symbol 'for) ['tag];
    @match = CallExpression (MemberExpression #Symbol 'for) ['match];
    constructors
    % map (\{name, parameters} -> Property (StringLiteral name) $ reduceRight
        (\body parameter -> ArrowFunctionExpression [Identifier parameter] body)
        (parameters
         % map (\name -> Property (StringLiteral name) (Identifier name))
         % concat [Property @tag (StringLiteral name)]
         % ObjectExpression)
        parameters
      )
    % concat [Property @match {
        #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] name;
        case {name, parameters} = {
          SwitchCase [Maybe.Just $ StringLiteral name] {
            reduce (\callee name -> CallExpression callee [MemberExpression #member $ StringLiteral name])
                   (MemberExpression #cases $ StringLiteral name)
                   parameters
          }
        };
        ArrowFunctionExpression [#default] {
          ArrowFunctionExpression [#cases] {
            ArrowFunctionExpression [#member] {
              ConditionalExpression
                (CallExpression (MemberExpression #Object 'hasOwn) [#cases, MemberExpression #member @tag])
                (SwitchExpression (MemberExpression #member @tag) (case <$> constructors))
                (Maybe.Just $ CallExpression #default [#member])
            }
          }
        }
      }]
    % ObjectExpression
    % VariableDeclaration $ Identifier name
    % rewriteNode
  },
  Module: \imports exports statements -> {
    Module (rewriteNode <$> imports) (rewriteNode <$> exports) (rewriteNode <$> statements)
  },
};

updateRenamerFromPattern rename node = flip (match Node) node {
  Identifier: \name -> {
    if preludeNames has name
    then \this -> if this == name then "$" + this else rename this
    else rename
  },
  ArrayPattern:   reduce updateRenamerFromPattern rename,
  ObjectPattern:  reduce updateRenamerFromPattern rename,
  Property:       const (updateRenamerFromPattern rename),
  RestElement:    updateRenamerFromPattern rename,
  Elision:        rename,
};

renameIdentifiers rename = {
  recur node = flip (match Node) node {
    Identifier: Identifier . rename,
    FunctionDeclaration: \name parameters -> FunctionDeclaration (rename name) (recur <$> parameters) . recur,
    ArrayExpression: ArrayExpression . map recur,
    ArrayPattern: ArrayPattern . map recur,
    ArrowFunctionExpression: \parameters -> ArrowFunctionExpression (recur <$> parameters) . recur,
    BinaryExpression: \operator left right -> BinaryExpression operator (recur left) (recur right),
    BlockExpression: \statements -> BlockExpression (recur <$> statements) . recur,
    BlockStatement: BlockStatement . map recur,
    BooleanLiteral: BooleanLiteral,
    CallExpression: \callee arguments -> CallExpression (recur callee) (recur <$> arguments),
    ConditionalExpression: \predicate consequent alternative -> ConditionalExpression (recur predicate) (recur consequent) (recur <$> alternative),
    Elision: Elision,
    ExportDefaultDeclaration: ExportDefaultDeclaration . recur,
    ExportNamedDeclaration: ExportNamedDeclaration . map recur,
    ExportSpecifier: ExportSpecifier . recur,
    ExpressionStatement: ExpressionStatement . recur,
    ImportDeclaration: \source -> ImportDeclaration source . map recur,
    ImportDefaultSpecifier: ImportDefaultSpecifier . recur,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier . recur,
    ImportSpecifier: \imported -> ImportSpecifier imported . recur,
    LogicalExpression: \operator left right -> LogicalExpression operator (recur left) (recur right),
    MemberExpression: \object property -> MemberExpression (recur object) (recur property),
    Module: \imports exports statements -> Module (recur <$> imports) (recur <$> exports) (recur <$> statements),
    NullLiteral: NullLiteral,
    NumberLiteral: NumberLiteral,
    ObjectExpression: ObjectExpression . map recur,
    ObjectPattern: ObjectPattern . map recur,
    Property: \key value -> Property (recur key) (recur value),
    RestElement: RestElement . recur,
    SpreadElement: SpreadElement . recur,
    StringLiteral: StringLiteral,
    SwitchCase: \predicates consequent -> SwitchCase (map recur <$> predicates) (recur consequent),
    SwitchExpression: \discriminant cases -> SwitchExpression (recur discriminant) (recur <$> cases),
    TemplateLiteral: \quasis expressions -> TemplateLiteral quasis (recur <$> expressions),
    UnaryExpression: \operator operand -> UnaryExpression operator (recur operand),
    VariableDeclaration: \pattern expression -> VariableDeclaration (recur pattern) (recur expression),
  };
  recur
};
