import * as Future from "fluture";

import Node from "./Node.serif";
import * as format from "./format.serif";
import Prelude from "./prelude.serif";

export default rewriteModule;

{
  StringLiteral,
  TemplateLiteral,
  MemberExpression,
  Identifier,
  SpreadElement,
  ArrayExpression,
  Property,
  ObjectExpression,
  ArrayPattern,
  ObjectPattern,
  RestElement,
  ArrowFunctionExpression,
  BlockExpression,
  UnaryExpression,
  CompositionExpression,
  BinaryExpression,
  LogicalExpression,
  ConditionalExpression,
  SwitchExpression,
  SwitchCase,
  CallExpression,
  ImportDeclaration,
  ImportSpecifier,
  ExportDefaultDeclaration,
  VariableDeclaration,
  FunctionDeclaration,
  ExpressionStatement,
  Module,
} = Node;

has element set = .has [element] set;

add element set = construct Set [[...set, element]];

union this that = construct Set [[...this, ...that]];

nextUnusedIdent names desiredName = {
  recur counter = {
    candidate = if counter == 0 then desiredName else desiredName + "$" + counter;
    if has candidate names then recur (counter + 1) else Identifier candidate
  };
  recur 0
};

namesInPattern = match' Node (const []) {
  Identifier: \name -> [name],
  ArrayPattern: \elements -> elements >>= namesInPattern,
  ObjectPattern: \properties -> properties >>= namesInPattern,
  Property: \key value -> namesInPattern value,
  RestElement: \argument -> namesInPattern argument,
};

namesInStatement = match' Node (const []) {
  ImportDeclaration: \source specifiers -> (.name) . (.local) <$> specifiers,
  VariableDeclaration: \pattern expression -> namesInPattern pattern,
  FunctionDeclaration: \name parameters body -> [name],
};

rewriteModule {imports, exports, statements} namesExportedFrom = do {
  imports' <- Future.parallel 16 $ rewriteImportDeclaration namesExportedFrom <$> imports;
  names = construct Set [imports' <> statements >>= namesInStatement];
  preludeIdent = nextUnusedIdent names "Prelude";
  names' = add preludeIdent.name names;
  fromPrelude = MemberExpression preludeIdent . StringLiteral;
  rewrite = rewriteNode fromPrelude names';
  preludeEntries = Object.entries $ Prelude fromPrelude;
  preludeDefinition = {
    VariableDeclaration preludeIdent {
      ObjectExpression {
        (\[name, value] -> Property (StringLiteral name) value) <$> preludeEntries
      }
    }
  };
  preludeDestructuring = {
    VariableDeclaration {
      ObjectPattern {
        preludeEntries >>= \[name] -> {
          ;; Do not unpack if name conflicts with a top-level binding:
          if has name names' then [] else [Property (StringLiteral name) (Identifier name)]
        }
      }
    } preludeIdent
  };
  Future.resolve {
    Module imports'
           (rewrite <$> exports)
           (rewrite <$> [preludeDefinition, preludeDestructuring, ...statements])
  }
};

rewriteImportAllDeclaration namesExportedFrom source hiding = {
  namesExported = {
    if .endsWith [".serif"] source.value then namesExportedFrom source.value
    else Object.keys <$> attemptP \() -> import source.value
  };
  namesHidden = (.name) <$> hiding;
  namesHiddenNeedlessly = reject (\name -> .includes [name] namesExported) namesHidden;
  if namesHiddenNeedlessly.length > 0 then {
    Future.reject $ Error {
      """import * from "${
        source.value
      }" hiding {${
        .join [", "] $ namesHidden
      }};\n\n${
        format.list namesHiddenNeedlessly
      } ${
        if namesHiddenNeedlessly.length == 1 then "is" else "are"
      } not exported so need not be hidden.\n"""
    }
  } else {
    namesExported
    | reject (\name -> .includes [name] namesHidden)
    | map (\name -> ImportSpecifier (Identifier name) (Identifier name))
    | ImportDeclaration source
    | Future.resolve
  }
};

rewriteImportDeclaration namesExportedFrom = {
  match Node {
    ImportDeclaration: \source specifiers -> Future.resolve $ ImportDeclaration source specifiers,
    ImportAllDeclaration: rewriteImportAllDeclaration namesExportedFrom,
  }
};

rewriteNode fromPrelude = {
  recur names = match' Node id {
    TemplateLiteral: \quasis expressions -> {
      TemplateLiteral quasis (recur names <$> expressions)
    },
    MemberExpression: \object property -> {
      MemberExpression (recur names object) (recur names property)
    },
    ArrayExpression: ArrayExpression . map (recur names),
    ObjectExpression: ObjectExpression . map (recur names),
    ArrowFunctionExpression: \parameters body -> {
      params = recur names <$> parameters;
      names' = union names $ (.name) <$> params;
      ArrowFunctionExpression params (recur names' body)
    },
    PropertyAccessor: \identifier -> {
      param = Identifier "x";
      names' = add param.name names;
      recur names' {
        ArrowFunctionExpression [param] {
          MemberExpression param $ StringLiteral identifier.name
        }
      }
    },
    BlockExpression: \statements -> {
      otherwise _ = {
        names' = union names $ statements >>= match' Node (const []) {
          VariableDeclaration: \pattern expression -> namesInPattern pattern,
          FunctionDeclaration: \name parameters body -> [name],
        };
        BlockExpression $ recur names' <$> statements
      };
      if statements.length == 1 then {
        match' Node otherwise {ExpressionStatement: recur names} statements[0]
      } else otherwise null
    },
    DoBlockExpression: \operations result -> {
      recur names $ reduceRight
        (\result -> match Node {
           ArrowAssignmentStatement: \pattern expression -> {
             CallExpression (CallExpression (fromPrelude "chain") [ArrowFunctionExpression [pattern] result]) [expression]
           },
           VariableDeclaration: \pattern expression -> {
             CallExpression (ArrowFunctionExpression [pattern] result) [expression]
           },
           FunctionDeclaration: \name parameters body -> {
             CallExpression (ArrowFunctionExpression [Identifier name] result) [
               reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
             ]
           },
         })
        result
        operations
    },
    UnaryExpression: \operator argument -> {
      UnaryExpression operator (recur names argument)
    },
    CompositionExpression: \left right -> {
      ;; Original expression: f . g . h
      ;;
      ;; Representation:   o
      ;;                  / \
      ;;                 f   o
      ;;                    / \
      ;;                   g   h
      ;;
      ;; Rewritten expression: \x -> f (g (h x))
      param = nextUnusedIdent names "x";
      names' = add param.name names;
      toCallExpression = {
        match' Node (flip CallExpression [param]) {
          CompositionExpression: \left right -> {
            CallExpression left [toCallExpression right]
          },
        }
      };
      CompositionExpression left right
      | toCallExpression
      | ArrowFunctionExpression [param]
      | recur names'
    },
    InfixCallExpression: \operator left right -> {
      recur names $ CallExpression (CallExpression operator [left]) [right]
    },
    BinaryExpression: \operator left right -> {
      switch operator
      when "==" then recur names $ CallExpression (CallExpression (fromPrelude "equals") [right]) [left]
      when "!=" then recur names $ CallExpression (fromPrelude "not") [BinaryExpression "==" left right]
      else BinaryExpression operator (recur names left) (recur names right)
    },
    ConcatenationExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "concat") [left]) [right]
    },
    MapExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "map") [left]) [right]
    },
    BindExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "chain") [right]) [left]
    },
    LogicalExpression: \operator left right -> {
      LogicalExpression operator (recur names left) (recur names right)
    },
    ConditionalExpression: \predicate consequent alternative -> {
      ConditionalExpression (recur names predicate)
                            (recur names consequent)
                            (recur names alternative)
    },
    SwitchExpression: \discriminant cases default -> {
      SwitchExpression (recur names discriminant)
                       (recur names <$> cases)
                       (if default == null then null else recur names default)
    },
    SwitchCase: \predicates consequent -> {
      SwitchCase (recur names <$> predicates) (recur names consequent)
    },
    PipeExpression: \head body -> {
      recur names $ CallExpression body [head]
    },
    MethodCallExpression: \name -> {
      recur names $ CallExpression (fromPrelude "_apply") [StringLiteral name]
    },
    CallExpression: \callee arguments -> {
      CallExpression (recur names callee) (recur names <$> arguments)
    },
    VariableDeclaration: \pattern expression -> {
      VariableDeclaration (recur names pattern) (recur names expression)
    },
    FunctionDeclaration: \name parameters body -> {
      FunctionDeclaration name (recur names <$> parameters) (recur names body)
    },
    ExpressionStatement: ExpressionStatement . recur names,
    ArrayPattern: ArrayPattern . map (recur names),
    ObjectPattern: ObjectPattern . map (recur names),
    SpreadElement: SpreadElement . recur names,
    RestElement: RestElement . recur names,
    Property: \key value -> Property (recur names key) (recur names value),
    ExportDefaultDeclaration: ExportDefaultDeclaration . recur names,
    DataTypeDeclaration: \name constructors -> {
      @tag = CallExpression (MemberExpression (Identifier "Symbol") $ StringLiteral "for") [StringLiteral "tag"];
      @match = CallExpression (MemberExpression (Identifier "Symbol") $ StringLiteral "for") [StringLiteral "match"];
      constructors
      | map (\{name, parameters} -> Property (StringLiteral name) $ reduceRight
          (\body parameter -> ArrowFunctionExpression [Identifier parameter] body)
          (parameters
           | map (\name -> Property (StringLiteral name) (Identifier name))
           | concat [Property @tag (StringLiteral name)]
           | ObjectExpression)
          parameters
        )
      | concat [Property @match {
          #default = Identifier "default";
          #cases = Identifier "cases";
          #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] name;
          case {name, parameters} = {
            SwitchCase [StringLiteral name] {
              reduce (\callee name -> CallExpression callee [MemberExpression #member $ StringLiteral name])
                     (MemberExpression #cases $ StringLiteral name)
                     parameters
            }
          };
          ArrowFunctionExpression [#default] {
            ArrowFunctionExpression [#cases] {
              ArrowFunctionExpression [#member] {
                ConditionalExpression
                  (CallExpression (MemberExpression (Identifier "Object") $ StringLiteral "hasOwn")
                                  [#cases, MemberExpression #member @tag])
                  (SwitchExpression (MemberExpression #member @tag)
                                    (case <$> constructors)
                                    null)
                  (CallExpression #default [#member])
              }
            }
          }
        }]
      | ObjectExpression
      | VariableDeclaration $ Identifier name
      | recur names
    },
  }
};
