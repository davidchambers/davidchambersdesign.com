import * as Future from "fluture";

import Maybe from "./Maybe.serif";
import Node from "./Node.serif";
import * as Set from "./Set.serif";
import * as format from "./format.serif";
import globals from "./globals.serif";
import Prelude from "./prelude.serif";

export default rewriteModule;

{
  StringLiteral,
  TemplateLiteral,
  MemberExpression,
  Identifier,
  SpreadElement,
  ArrayExpression,
  Property,
  ObjectExpression,
  ArrayPattern,
  ObjectPattern,
  RestElement,
  ArrowFunctionExpression,
  BlockExpression,
  UnaryExpression,
  CompositionExpression,
  BinaryExpression,
  LogicalExpression,
  ConditionalExpression,
  SwitchExpression,
  SwitchCase,
  CallExpression,
  ImportDeclaration,
  ImportSpecifier,
  ExportDefaultDeclaration,
  VariableDeclaration,
  FunctionDeclaration,
  ExpressionStatement,
  Module,
} = Node;

nextUnusedIdent names desiredName = {
  recur counter = {
    candidate = if counter == 0 then desiredName else desiredName + "$" + counter;
    if Set.has candidate names then recur (counter + 1) else Identifier candidate
  };
  recur 0
};

variables declared referenced = {declared, referenced};
declaring   names = variables names Set.empty;
referencing names = variables Set.empty names;
empty             = variables Set.empty Set.empty;

declared   = (.declared);
referenced = (.referenced);

merge lhs rhs = {
  declared:   Set.union lhs.declared rhs.declared,
  referenced: Set.union lhs.referenced rhs.referenced,
};

mergeAll = reduce merge empty;

foo bar = baz;

vars = match' Node (const empty) {
  TemplateLiteral: \quasis -> mergeAll . map vars,
  MemberExpression: \object property -> vars object `merge` vars property,
  Identifier: \name -> referencing $ Set.of name,
  SpreadElement: \argument -> vars argument,
  ArrayExpression: mergeAll . map vars,
  Property: \key value -> vars key `merge` vars value,
  ObjectExpression: \properties -> mergeAll $ vars <$> properties,
  ArrayPattern: \elements -> mergeAll $ vars <$> elements,
  ObjectPattern: \properties -> mergeAll $ vars <$> properties,
  RestElement: \argument -> vars argument,
  ArrowFunctionExpression: \parameters body -> {
    referencing $ Set.without (referenced $ mergeAll $ vars <$> parameters) (referenced $ vars $ body)
  },
  BlockExpression: \statements -> {
    {declared, referenced} = mergeAll (vars <$> statements);
    referencing $ Set.without declared referenced
  },
  DoBlockExpression: \operations result -> referencing {
    reduceRight (\names -> match Node {
      FunctionDeclaration:    \name parameters body -> Set.without (referenced $ mergeAll $ vars <$> parameters) $ Set.union names $ referenced $ vars body,
      VariableDeclaration:      \pattern expression -> Set.union (referenced $ vars expression) $ Set.without (referenced $ vars pattern) names,  ;; x <- f x;
      ArrowAssignmentStatement: \pattern expression -> Set.union (referenced $ vars expression) $ Set.without (referenced $ vars pattern) names,  ;; x = f x;
    }) (referenced $ vars result) operations
  },
  UnaryExpression: \operator -> vars,
  CompositionExpression: \left right -> vars left `merge` vars right,
  InfixCallExpression: \operator left right -> vars operator `merge` vars left `merge` vars right,
  BinaryExpression: \operator left right -> vars left `merge` vars right,
  ConcatenationExpression: \left right -> vars left `merge` vars right,
  MapExpression: \left right -> vars left `merge` vars right,
  BindExpression: \left right -> vars left `merge` vars right,
  LogicalExpression: \operator left right -> vars left `merge` vars right,
  ConditionalExpression: \predicate consequent alternative -> vars predicate `merge` vars consequent `merge` vars alternative,
  SwitchExpression: \discriminant cases -> mergeAll $ vars <$> [discriminant, ...cases],
  SwitchCase: \predicates consequent -> mergeAll $ vars <$> [...predicates, consequent],
  PipeExpression: \head body -> vars head `merge` vars body,
  CallExpression: \callee arguments -> mergeAll $ vars <$> [callee, ...arguments],
  ImportDeclaration: \source -> mergeAll . map vars,
  ImportAllDeclaration: \source hiding -> empty,
  ImportDefaultSpecifier: \local -> declaring $ referenced $ vars local,
  ImportSpecifier: \local imported -> declaring $ referenced $ vars local,
  ImportNamespaceSpecifier: \local -> declaring $ referenced $ vars local,
  ExportNamedDeclaration: \specifiers -> mergeAll $ vars <$> specifiers,
  ExportDefaultDeclaration: \declaration -> vars declaration,
  ExportSpecifier: \local exported -> vars local,
  VariableDeclaration: \pattern expression -> variables (referenced $ vars pattern) (referenced $ vars expression),
  FunctionDeclaration: \name parameters body -> {
    names = Set.add name (referenced $ mergeAll $ vars <$> parameters);
    variables (Set.of name)
              (Set.without names $ referenced $ vars body)
  },
  ExpressionStatement: \expression -> vars expression,
  Module: \imports exports statements -> mergeAll $ vars <$> imports <> exports <> statements,
  DataTypeDeclaration: \name constructors -> declaring $ Set.of name,
};

rewriteModule module namesExportedFrom = do {
  {declared, referenced} = vars module;
  undeclared = Set.without declared referenced;
  imports <- Future.parallel 16 $ rewriteImportDeclaration undeclared namesExportedFrom <$> module.imports;
  module = Module imports module.exports module.statements;
  {declared, referenced} = vars module;
  unreferenced = Set.without referenced declared;
  undeclared = Set.without declared referenced;
  preludeIdent = nextUnusedIdent declared "Prelude";
  declared = Set.add preludeIdent.name declared;
  fromPrelude = MemberExpression preludeIdent . StringLiteral;
  rewrite = rewriteNode fromPrelude declared;
  preludeEntries = Object.entries $ Prelude fromPrelude;
  preludeNames = (\[name] -> name) <$> preludeEntries;
  _ = {
    unreferenced' = Set.sub preludeIdent.name unreferenced;
    undeclared' = Set.without (preludeNames | Set.union globals | Set.add "import" | Set.add "console" | Set.add "fetch") undeclared;
    if unreferenced'.size == 0 then undefined else (unreferenced' | Array.from | .join [", "] | concat "unreferenced: " | console.error);
    if undeclared'.size   == 0 then undefined else (undeclared'   | Array.from | .join [", "] | concat "undeclared: "   | console.error);
    undefined
  };
  preludeDefinition = {
    VariableDeclaration preludeIdent {
      ObjectExpression {
        (\[name, value] -> Property (StringLiteral name) value) <$> preludeEntries
      }
    }
  };
  preludeDestructuring = {
    VariableDeclaration {
      ObjectPattern {
        preludeNames >>= \name -> {
          ;; Do not unpack if name conflicts with a top-level binding:
          if Set.has name declared then [] else [Property (StringLiteral name) (Identifier name)]
        }
      }
    } preludeIdent
  };
  Future.resolve {
    Module module.imports
           (rewrite <$> module.exports)
           (rewrite <$> [preludeDefinition, preludeDestructuring, ...module.statements])
  }
};

rewriteImportAllDeclaration undeclared namesExportedFrom source hiding = {
  namesExported = {
    if .endsWith [".serif"] source.value then namesExportedFrom source.value
    else Object.keys <$> Future.attemptP \() -> import source.value
  };
  namesHidden = (.name) <$> hiding;
  namesHiddenNeedlessly = reject (\name -> .includes [name] namesExported) namesHidden;
  if namesHiddenNeedlessly.length > 0 then {
    Future.reject $ Error {
      """import * from "${
        source.value
      }" hiding {${
        .join [", "] $ namesHidden
      }};\n\n${
        format.list namesHiddenNeedlessly
      } ${
        if namesHiddenNeedlessly.length == 1 then "is" else "are"
      } not exported so need not be hidden.\n"""
    }
  } else {
    namesExported
    | filter (flip Set.has undeclared)
    | reject (\name -> .includes [name] namesHidden)
    | map (\name -> ImportSpecifier (Identifier name) (Identifier name))
    | ImportDeclaration source
    | Future.resolve
  }
};

rewriteImportDeclaration undeclared namesExportedFrom = {
  match Node {
    ImportDeclaration: \source specifiers -> Future.resolve $ ImportDeclaration source specifiers,
    ImportAllDeclaration: rewriteImportAllDeclaration undeclared namesExportedFrom,
  }
};

rewriteNode fromPrelude = {
  recur names = match' Node id {
    TemplateLiteral: \quasis expressions -> {
      TemplateLiteral quasis (recur names <$> expressions)
    },
    MemberExpression: \object property -> {
      MemberExpression (recur names object) (recur names property)
    },
    ArrayExpression: ArrayExpression . map (recur names),
    ObjectExpression: ObjectExpression . map (recur names),
    ArrowFunctionExpression: \parameters body -> {
      params = recur names <$> parameters;
      names' = Set.union names $ (.name) <$> params;
      ArrowFunctionExpression params (recur names' body)
    },
    PropertyAccessor: \identifier -> {
      param = Identifier "x";
      names' = Set.add param.name names;
      recur names' {
        ArrowFunctionExpression [param] {
          MemberExpression param $ StringLiteral identifier.name
        }
      }
    },
    BlockExpression: \statements -> {
      if statements.length == 1 then {
        match' Node (\_ ->
          statements
          | map (recur $ Set.union names (declared $ mergeAll $ vars <$> statements))
          | BlockExpression
        ) {ExpressionStatement: recur names} statements[0]
      } else {
        statements
        | map (recur $ Set.union names (declared $ mergeAll $ vars <$> statements))
        | BlockExpression
      }
    },
    DoBlockExpression: \operations result -> {
      recur names $ reduceRight (\result -> match Node {
        ArrowAssignmentStatement: \pattern expression -> {
          CallExpression (CallExpression (fromPrelude "chain") [ArrowFunctionExpression [pattern] result]) [expression]
        },
        VariableDeclaration: \pattern expression -> {
          CallExpression (ArrowFunctionExpression [pattern] result) [expression]
        },
        FunctionDeclaration: \name parameters body -> {
          CallExpression (ArrowFunctionExpression [Identifier name] result) [
            reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
          ]
        },
      }) result operations
    },
    UnaryExpression: \operator argument -> {
      UnaryExpression operator (recur names argument)
    },
    CompositionExpression: \left right -> {
      ;; Original expression: f . g . h
      ;;
      ;; Representation:   o
      ;;                  / \
      ;;                 f   o
      ;;                    / \
      ;;                   g   h
      ;;
      ;; Rewritten expression: \x -> f (g (h x))
      param = nextUnusedIdent names "x";
      names' = Set.add param.name names;
      toCallExpression node = {
        match' Node (flip CallExpression [param]) {
          CompositionExpression: \left right -> {
            CallExpression left [toCallExpression right]
          },
        } node
      };
      CompositionExpression left right
      | toCallExpression
      | ArrowFunctionExpression [param]
      | recur names'
    },
    InfixCallExpression: \operator left right -> {
      recur names $ CallExpression (CallExpression operator [left]) [right]
    },
    BinaryExpression: \operator left right -> {
      switch operator
      when "==" then recur names $ CallExpression (CallExpression (fromPrelude "equals") [right]) [left]
      when "!=" then recur names $ CallExpression (fromPrelude "not") [BinaryExpression "==" left right]
      else BinaryExpression operator (recur names left) (recur names right)
    },
    ConcatenationExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "concat") [left]) [right]
    },
    MapExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "map") [left]) [right]
    },
    BindExpression: \left right -> {
      recur names $ CallExpression (CallExpression (fromPrelude "chain") [right]) [left]
    },
    LogicalExpression: \operator left right -> {
      LogicalExpression operator (recur names left) (recur names right)
    },
    ConditionalExpression: \predicate consequent alternative -> {
      ConditionalExpression (recur names predicate)
                            (recur names consequent)
                            (recur names alternative)
    },
    SwitchExpression: \discriminant cases -> {
      SwitchExpression (recur names discriminant) (recur names <$> cases)
    },
    SwitchCase: \predicates consequent -> {
      SwitchCase (map (map $ recur names) predicates) (recur names consequent)
    },
    PipeExpression: \head body -> {
      recur names $ CallExpression body [head]
    },
    MethodCallExpression: \name -> {
      recur names $ CallExpression (fromPrelude "_apply") [StringLiteral name]
    },
    CallExpression: \callee arguments -> {
      CallExpression (recur names callee) (recur names <$> arguments)
    },
    VariableDeclaration: \pattern expression -> {
      VariableDeclaration (recur names pattern) (recur names expression)
    },
    FunctionDeclaration: \name parameters body -> {
      FunctionDeclaration name (recur names <$> parameters) (recur names body)
    },
    ExpressionStatement: ExpressionStatement . recur names,
    ArrayPattern: ArrayPattern . map (recur names),
    ObjectPattern: ObjectPattern . map (recur names),
    SpreadElement: SpreadElement . recur names,
    RestElement: RestElement . recur names,
    Property: \key value -> Property (recur names key) (recur names value),
    ExportDefaultDeclaration: ExportDefaultDeclaration . recur names,
    DataTypeDeclaration: \name constructors -> {
      @tag = CallExpression (MemberExpression (Identifier "Symbol") $ StringLiteral "for") [StringLiteral "tag"];
      @match = CallExpression (MemberExpression (Identifier "Symbol") $ StringLiteral "for") [StringLiteral "match"];
      constructors
      | map (\{name, parameters} -> Property (StringLiteral name) $ reduceRight
          (\body parameter -> ArrowFunctionExpression [Identifier parameter] body)
          (parameters
           | map (\name -> Property (StringLiteral name) (Identifier name))
           | concat [Property @tag (StringLiteral name)]
           | ObjectExpression)
          parameters
        )
      | concat [Property @match {
          #default = Identifier "default";
          #cases = Identifier "cases";
          #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] name;
          case {name, parameters} = {
            SwitchCase [Maybe.Just $ StringLiteral name] {
              reduce (\callee name -> CallExpression callee [MemberExpression #member $ StringLiteral name])
                     (MemberExpression #cases $ StringLiteral name)
                     parameters
            }
          };
          ArrowFunctionExpression [#default] {
            ArrowFunctionExpression [#cases] {
              ArrowFunctionExpression [#member] {
                ConditionalExpression
                  (CallExpression (MemberExpression (Identifier "Object") $ StringLiteral "hasOwn")
                                  [#cases, MemberExpression #member @tag])
                  (SwitchExpression (MemberExpression #member @tag) (case <$> constructors))
                  (CallExpression #default [#member])
              }
            }
          }
        }]
      | ObjectExpression
      | VariableDeclaration $ Identifier name
      | recur names
    },
  }
};
