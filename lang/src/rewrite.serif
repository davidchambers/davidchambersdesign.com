import * from "./Maybe.serif";
import Node, * from "./Node.serif";
import globals from "./globals.serif";
import Prelude from "./prelude.serif";
import vars from "./vars.serif";

export default rewriteModule;

preludeNames = construct Set [Object.keys Prelude];

removeUnreferencedPreludeFunctions module = {
  {declared, referenced} = vars module;
  unreferenced = declared - referenced;
  unnecessary = unreferenced & preludeNames;
  statements = reject (Node.matchOr (const false) {VariableDeclaration: \{name} _ -> unnecessary has name}) module.statements;
  if statements.length == module.statements.length
  then module
  else removeUnreferencedPreludeFunctions $ Module module.imports module.exports statements
};

rewriteModule module = {
  ;; desugar first to simplify subsequent steps
  module' = rewriteNode module;
  ;; create renaming function based on variable and function declarations
  rename = reduce (\rename -> Node.match {
    DataTypeDeclaration: const $ const rename,
    VariableDeclaration: \pattern expression -> updateRenamerFromPattern rename pattern,
    ExpressionStatement: const rename,
  }) id module'.statements;
  ;; wrap renaming function based on import declarations
  rename' = reduce (\rename -> Node.match {
    ImportSpecifier: \imported local name -> if name == imported.name then local.name else rename name,
    ImportNamespaceSpecifier: updateRenamerFromPattern rename,
    ImportDefaultSpecifier: updateRenamerFromPattern rename,
  }) rename $ module'.imports >>= (.specifiers);
  ;; rename identifiers
  module'' = renameIdentifiers rename' module';
  ;; insert prelude
  prelude = (\[name, value] -> VariableDeclaration (Identifier name) value) <$> Object.entries Prelude;
  module''' = Module module''.imports module''.exports $ prelude <> module''.statements;
  ;; remove unreferenced prelude functions
  module'''' = removeUnreferencedPreludeFunctions module''';
  {declared, referenced} = vars module'''';
  unreferenced = declared - referenced;
  undeclared = referenced - declared - globals - construct Set [["CasesNotExhaustive", "DivisionByZero", "import", "console", "fetch"]];
  if unreferenced.size > 0 then (unreferenced % Array.from % .join [", "] % concat "unreferenced: " % console.error);
  if undeclared.size   > 0 then (undeclared   % Array.from % .join [", "] % concat "undeclared: "   % console.error);
  module''''
};

#$              = Identifier "$";
#$cases         = Identifier "$cases";
#$default       = Identifier "$default";
#$lhs           = Identifier "$lhs";
#$rhs           = Identifier "$rhs";
#Object         = Identifier "Object";
#Symbol         = Identifier "Symbol";
#args           = Identifier "args";
#map            = Identifier "map";
#recur          = Identifier "recur";
#target         = Identifier "target";

'apply          = StringLiteral "apply";
'for            = StringLiteral "for";
'has            = StringLiteral "has";
'hasOwn         = StringLiteral "hasOwn";
'tag            = StringLiteral "tag";

@tag            = CallExpression (MemberExpression #Symbol 'for) ['tag];

rewriteNode = Node.transform {
  PropertyAccessor: \{name} -> {
    rewriteNode $ ArrowFunctionExpression [#$] $ MemberExpression #$ $ StringLiteral name
  },
  LeftSection: \operator lhs -> {
    rewriteNode $ ArrowFunctionExpression [#$rhs] $ InfixExpression operator lhs #$rhs
  },
  RightSection: \operator rhs -> {
    rewriteNode $ ArrowFunctionExpression [#$lhs] $ InfixExpression operator #$lhs rhs
  },
  EmptySection: \operator -> {
    rewriteNode $ ArrowFunctionExpression [#$lhs] $ ArrowFunctionExpression [#$rhs] $ InfixExpression operator #$lhs #$rhs
  },
  Block: \statements result -> {
    if statements == []
    then rewriteNode $ fromJust! result
    else Block (rewriteNode <$> statements) (rewriteNode <$> result)
  },
  DoBlockExpression: \operations result -> {
    rewriteNode $ reduceRight (\result -> Node.match {
      ArrowAssignmentStatement: \pattern expression -> {
        CallExpression (CallExpression (Identifier "chain") [ArrowFunctionExpression [pattern] result]) [expression]
      },
      VariableDeclaration: \pattern expression -> {
        CallExpression (ArrowFunctionExpression [pattern] result) [expression]
      },
      FunctionDeclaration: \name parameters body -> {
        CallExpression (ArrowFunctionExpression [Identifier name] result) [
          reduceRight (\body param -> ArrowFunctionExpression [param] body) body parameters,
        ]
      },
      ExpressionStatement: \expression -> {
        Block [ExpressionStatement expression] $ Just result
      },
    }) result operations
  },
  InfixCallExpression: \operator left right -> {
    rewriteNode $ CallExpression (CallExpression operator [left]) [right]
  },
  InfixExpression: \operator lhs rhs -> {
    switch operator
    when "."   then rewriteNode $ CallExpression (CallExpression (Identifier "compose" ) [lhs]) [rhs]
    when "-"   then rewriteNode $ CallExpression (CallExpression (Identifier "subtract") [rhs]) [lhs]
    when "<>"  then rewriteNode $ CallExpression (CallExpression (Identifier "concat"  ) [lhs]) [rhs]
    when "has" then rewriteNode $ CallExpression                    (MemberExpression lhs 'has) [rhs]
    when "in"  then rewriteNode $ CallExpression (CallExpression (Identifier "contains") [lhs]) [rhs]
    when "=="  then rewriteNode $ CallExpression (CallExpression (Identifier "equals"  ) [rhs]) [lhs]
    when "!="  then rewriteNode $ CallExpression    (Identifier "not") [InfixExpression "==" lhs rhs]
    when "<$>" then rewriteNode $ CallExpression (CallExpression (Identifier "map"     ) [lhs]) [rhs]
    when "&"   then rewriteNode $ CallExpression (CallExpression (Identifier "AND"     ) [rhs]) [lhs]
    when "^"   then rewriteNode $ CallExpression (CallExpression (Identifier "XOR"     ) [rhs]) [lhs]
    when "|"   then rewriteNode $ CallExpression (CallExpression (Identifier "OR"      ) [rhs]) [lhs]
    when ">>=" then rewriteNode $ CallExpression (CallExpression (Identifier "chain"   ) [rhs]) [lhs]
    when "$"   then rewriteNode $ CallExpression lhs [rhs]
    when "%"   then rewriteNode $ CallExpression rhs [lhs]
    else InfixExpression operator (rewriteNode lhs) (rewriteNode rhs)
  },
  MethodCallExpression: \name -> {
    rewriteNode {
      ArrowFunctionExpression [#args] {
        ArrowFunctionExpression [#target] {
          CallExpression (MemberExpression (MemberExpression #target $ StringLiteral name) 'apply) [#target, #args]
        }
      }
    }
  },
  CallExpression: flip \arguments -> {
    Node.matchOr (\callee -> CallExpression (rewriteNode callee) (rewriteNode <$> arguments)) {
      PropertyAccessor: rewriteNode . MemberExpression arguments[0] . StringLiteral . (.name),
    }
  },
  FunctionDeclaration: \name parameters body -> rewriteNode {
    VariableDeclaration (Identifier name)
                        (reduceRight (flip $ ArrowFunctionExpression . Array.of) body parameters)
  },
  DataTypeDeclaration: \identifier constructors -> rewriteNode {
    #member = Identifier $ .replace [RegExp "^.", .toLowerCase []] identifier.name;

    pattern = {
      constructors
      % map (.identifier)
      % prepend identifier
      % map (join Property)
      % ObjectPattern
    };
    VariableDeclaration pattern {
      #$matchOr   = Identifier "$matchOr";
      #$match     = Identifier "$match";
      #$transform = Identifier "$transform";
      #$foldRec   = Identifier "$foldRec";

      variableDeclarationFromConstructor = Node.match {
        DataConstructorDefinition: \identifier parameters -> {
          VariableDeclaration identifier $ reduceRight
            (\body parameter -> ArrowFunctionExpression [parameter.identifier] body)
            (parameters
             % map (.identifier)
             % map (\parameter -> Property (StringLiteral parameter.name) parameter)
             % prepend (Property @tag (StringLiteral identifier.name))
             % ObjectExpression)
            parameters
        },
      };

      matchOr = {
        case {identifier, parameters} = {
          SwitchCase [Just $ StringLiteral identifier.name] {
            reduce (\callee parameter -> CallExpression callee [MemberExpression #member $ StringLiteral parameter.identifier.name])
                   (MemberExpression #$cases $ StringLiteral identifier.name)
                   parameters
          }
        };
        ArrowFunctionExpression [#$default] {
          ArrowFunctionExpression [#$cases] {
            ArrowFunctionExpression [#member] {
              ConditionalExpression
                (CallExpression (MemberExpression #Object 'hasOwn) [#$cases, MemberExpression #member @tag])
                (SwitchExpression (MemberExpression #member @tag) (case <$> constructors))
                (Just $ CallExpression #$default [#member])
            }
          }
        }
      };

      withRecursion expr recur depth = {
        switch depth
        when 0 then expr
        when 1 then CallExpression recur [expr]
        else withRecursion expr (CallExpression #map [recur]) (depth - 1)
      };

      transform = {
        ArrowFunctionExpression [#$cases] {
          Block [
            VariableDeclaration #recur {
              CallExpression (CallExpression #$matchOr [identifier]) [
                constructors
                % map (Node.match {
                    DataConstructorDefinition: \identifier parameters -> Property (StringLiteral identifier.name) {
                      reduceRight (\body parameter -> ArrowFunctionExpression [parameter.identifier] body)
                                  (reduce (\callee -> Node.match {
                                             DataConstructorParameter: \identifier recursionDepth -> {
                                               CallExpression callee [withRecursion identifier #recur recursionDepth]
                                             }
                                           })
                                          identifier
                                          parameters)
                                  parameters
                    }
                  })
                % append (SpreadElement #$cases)
                % ObjectExpression
              ]
            },
          ] $ Just #recur
        }
      };

      foldRec = {
        ArrowFunctionExpression [#$cases] {
          Block [
            VariableDeclaration #recur {
              CallExpression (CallExpression #$matchOr [identifier]) [
                constructors
                % map (Node.match {
                    DataConstructorDefinition: \identifier parameters -> Property (StringLiteral identifier.name) {
                      reduceRight (\body parameter -> ArrowFunctionExpression [parameter.identifier] body)
                                  (reduce (\callee -> Node.match {
                                             DataConstructorParameter: \identifier recursionDepth -> {
                                               CallExpression callee [withRecursion identifier #recur recursionDepth]
                                             }
                                           })
                                          (MemberExpression #$cases $ StringLiteral identifier.name)
                                          parameters)
                                  parameters
                    }
                  })
                % ObjectExpression
              ]
            },
          ] $ Just #recur
        }
      };

      constructors
      % map (Node.match {
          DataConstructorDefinition: \identifier parameters -> {
            Property (StringLiteral identifier.name) identifier
          }
        })
      % append {
          Property (StringLiteral identifier.name) $ ObjectExpression [
            Property (StringLiteral "matchOr"  ) #$matchOr,
            Property (StringLiteral "match"    ) #$match,
            Property (StringLiteral "transform") #$transform,
            Property (StringLiteral "foldRec"  ) #$foldRec,
          ]
        }
      % ObjectExpression
      % Just
      % Block [
          ...(variableDeclarationFromConstructor <$> constructors),
          VariableDeclaration #$matchOr matchOr,
          VariableDeclaration #$match $ CallExpression #$matchOr [ArrowFunctionExpression [#member] $ Identifier "CasesNotExhaustive"],
          VariableDeclaration #$transform transform,
          VariableDeclaration #$foldRec foldRec,
        ]
    }
  },
};

updateRenamerFromPattern rename = Node.match {
  Identifier:          \name -> if preludeNames has name then \this -> if this == name then "$" + this else rename this else rename,
  ArrayPattern:    \elements -> reduce updateRenamerFromPattern rename elements,
  ObjectPattern: \properties -> reduce updateRenamerFromPattern rename properties,
  Property:       \key value -> updateRenamerFromPattern rename value,
  RestElement:     \argument -> updateRenamerFromPattern rename argument,
  Elision:                      rename,
};

renameIdentifiers rename = Node.transform {
  Identifier: Identifier . rename,
  ImportSpecifier: \imported local -> ImportSpecifier imported (renameIdentifiers rename local),
  ExportSpecifier: \local exported -> ExportSpecifier (renameIdentifiers rename local) exported,
};
