import os from "node:os";
import repl from "node:repl";
import vm from "node:vm";

import {generate} from "astring";
import {attemptP, fork, promise, resolve} from "fluture";

import * as serif from "./index.serif";
import * as path from "./path.serif";

evaluateModule sourceText = do {
  context = vm.createContext globalThis;
  module = construct vm.SourceTextModule [sourceText, {context,}];
  _ <- attemptP \() -> .link [
    \(specifier, referencingModule) -> {
      attemptP (\() -> import specifier)
      | map Object.entries
      | map $ map \entries -> {
          module = construct vm.SyntheticModule [
            {\[name] -> name} <$> entries,
            \() -> .forEach [flip {.setExport} module] entries,
            {identifier: specifier, context: referencingModule.context},
          ];
          module
        }
      | promise
    },
  ] module;
  _ <- attemptP \() -> .evaluate [] module;
  resolve module.namespace.default
};

read serifSource = do {
  serifAst <- serif.parse "[repl]" $ "export default " + serifSource + ";";
  serifAst' <- serif.rewrite serifAst \_importPath -> [];  ;; TODO: support import statements
  serifAst'' = serif.changeExtensions serifAst';
  esAst = serif.esModuleFromSerifModule serifAst'';
  esSourceText = apply generate [esAst, {}];
  evaluateModule esSourceText
};

#0  = "\x1B[0m";
#32 = "\x1B[32m";
#33 = "\x1B[33m";
#35 = "\x1B[35m";

print x = {
  switch apply Reflect.apply [Object.prototype.toString, x, []]
  when "[object Null]",
       "[object Undefined]",
       "[object Boolean]"
  then #35 + x + #0
  when "[object Number]"
  then #33 + x + #0
  when "[object String]"
  then #32 + JSON.stringify x + #0
  when "[object Symbol]"
  then "Symbol.for " + (print $ Symbol.keyFor x)
  when "[object Date]"
  then "construct Date [" + (print $ Number x) + "]"
  when "[object RegExp]"
  then if x.flags == "" then "RegExp " + (print x.source) else "construct RegExp [" + (print x.source) + ", " + (print x.flags) + "]"
  when "[object Set]"
  then "construct Set [" + (print $ Array.from x) + "]"
  when "[object Map]"
  then "construct Map [" + (print $ Array.from x) + "]"
  when "[object Array]"
  then "[" + (.join [", "] $ print <$> x) + "]"
  when "[object Object]"
  then "{" + (.join [", "] $ map (\k -> "[" + (print k) + "]: " + (print x[k])) $ Reflect.ownKeys x) + "}"
  else String x
};

server = repl.start {
  prompt: ">>> ",
  eval: \(code, _context, _filename, callback) -> {
    fork (\err -> {
            console.error err;
            console.log "";
            .displayPrompt [false] server
          })
         (\result -> {
            apply callback [null, result]
          })
         (read code)
  },
  writer: \value -> print value + "\n",
};

.setupHistory [
  path.join [apply os.homedir [], ".serif-repl-history"],
  \error -> undefined
] server;
