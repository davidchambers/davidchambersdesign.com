import {attempt, attemptP, fork, resolve} from "fluture";
import {generate} from "astring";

import * as Node from "./Node.serif";
import * as serif from "./index.serif";

;; good example of interop (not actually used here)
readInput reader = {
  decoder = construct TextDecoder [];
  uint8 = construct Uint8Array [1024];
  recur text = do {
    n <- attemptP \() -> reader.read uint8;
    if n == null
    then resolve text
    else recur $ concat text $ decoder.decode $ .slice [0, n] uint8
  };
  recur ""
};

#0  = "\x1B[0m";
#1  = "\x1B[1m";
#7  = "\x1B[7m";
#22 = "\x1B[22m";
#27 = "\x1B[27m";
#32 = "\x1B[32m";
#33 = "\x1B[33m";
#35 = "\x1B[35m";

print x = {
  switch .call [x] Object.prototype.toString
  when "[object Null]",
       "[object Undefined]",
       "[object Boolean]"
  then #35 + x + #0
  when "[object Number]"
  then #33 + x + #0
  when "[object String]"
  then #32 + JSON.stringify x + #0
  when "[object Symbol]"
  then "Symbol.for " + (print $ Symbol.keyFor x)
  when "[object Date]"
  then "construct Date [" + (print $ Number x) + "]"
  when "[object RegExp]"
  then if x.flags == "" then "RegExp " + (print x.source) else "RegExp (" + (print x.source) + ", " + (print x.flags) + ")"
  when "[object Set]"
  then "construct Set [" + (print $ Array.from x) + "]"
  when "[object Map]"
  then "construct Map [" + (print $ Array.from x) + "]"
  when "[object Array]"
  then "[" + (.join [", "] $ print <$> x) + "]"
  when "[object Object]"
  then "{" + (.join [", "] $ map (\k -> "[" + (print k) + "]: " + (print x[k])) $ Reflect.ownKeys x) + "}"
  else String x
};

processInput serifSourceText = do {
  serifAst <- serif.parse "[repl]" $ "export default " <> serifSourceText <> ";";
  serifAst <- serif.rewrite serifAst \importPath -> [];  ;; TODO: support import statements
  {exports, statements} = serif.changeExtensions serifAst;
  esAst = serif.esModuleFromSerifModule $ Node.BlockExpression statements exports[0].declaration;
  esSourceText = generate esAst;
  esResult <- attempt \() -> eval esSourceText;
  resolve $ print esResult
};

repl _ = {
  input = prompt "\n>>>";
  if .trim [] input in [":exit", ":quit"]
  then { console.log ""; Deno.exit () }
  else fork (repl . console.error) (repl . console.log) (processInput input)
};
console.log $ #7 <> " Serif REPL " <> #27 <> " " <> #1 <> ":quit" <> #22 <> " to exit";
repl 8;
