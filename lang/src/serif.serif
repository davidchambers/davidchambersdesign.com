import {generate} from "astring";
import {fork, mapRej, parallel, resolve} from "fluture";

import Node from "./Node.js";
import * as fs from "./fs.serif";
import * as serif from "./index.serif";
import * as path from "./path.serif";

parse filename sourceText = {
  {serif.parse filename sourceText} % mapRej \error -> {
    lines = {
      sourceText
      % .split [RegExp ("^", "m")]
      % .map [\(text, index) -> {number: index + 1, text: .trimEnd [] text}]
      % chain \line -> {
          offset = line.number - error.location.start.line;
          if offset > -5 and offset <= 0 then [line] else []
        }
    };
    renderLineNumber = .padStart [4] . String;
    """\n\x1B[1m${
      path.relative (Deno.cwd ()) error.location.source
    }\x1B[0m\n\n${
      lines
      % .map [\(line, idx, lines) -> {
          """\x1B[7m${
            renderLineNumber line.number
          }\x1B[0m${
            if idx < lines.length - 1 then line.text else {
              """${
                .slice [0, error.location.start.column - 1] line.text
              }\x1B[7m${
                .charAt [error.location.start.column - 1] line.text
              }\x1B[0m${
                .slice [error.location.start.column] line.text
              }"""
            }
          }\n"""
        }]
      % .join [""]
    }${
      lines
      % .at [-1]
      % (.number)
      % renderLineNumber
      % (.length)
      % \length -> .repeat [length + error.location.start.column - 1] " "
    }^\n${
      error.message
    }\n"""
  }
};

reducer futureTree filename = {
  futureTree >>= findDependencies filename
};

findDependencies filename tree = {
  if tree has filename then resolve tree else do {
    sourceText <- mapRej (.message) $ fs.readFile filename;
    ast <- parse filename sourceText;
    dependencies = ast.imports >>= \{source: {value}} -> {
      if .test [value] $ RegExp "^[./].*[.]serif$"
      then [path.join [filename, "..", value]]
      else []
    };
    exportedNames = ast.exports >>= match' Node (const []) {ExportNamedDeclaration: map ((.name) . (.exported))};
    reduce reducer
           (resolve $ construct Map [[...tree, [filename, {sourceText, ast, dependencies, exportedNames}]]])
           dependencies
  }
};

orderDependencies tree = {
  recur unsorted! sorted! = {
    if unsorted! == [] then sorted! else {
      filename = .shift [] unsorted!;
      {dependencies} = .get [filename] tree;
      if .every [\filename -> sorted! has filename] dependencies
      then .add [filename] sorted!
      else .push [filename] unsorted!;
      recur unsorted! sorted!
    }
  };
  Array.from $ recur (Array.from $ .keys [] tree) $ empty Set
};

{
  cwd = Deno.cwd ();
  [src, dst, ...filenames] = Deno.args;
  toAbs abs rel = path.join $ [abs] <> .split ["/"] rel;  ;; use / (even on Windows)
  absSrc = toAbs cwd src;
  absDst = toAbs cwd dst;
  absFilenames = toAbs absSrc <$> filenames;
  program = do {
    tree <- reduce reducer (resolve $ construct Map [[]]) absFilenames;
    filenames = orderDependencies tree;
    ;; Create JavaScript module for each Serif module:
    parallel 16 $ flip map filenames \serifFilename -> do {
      serifDirname = path.dirname serifFilename;
      serifAst = (.ast) $ .get [serifFilename] tree;
      serifAst' <- serif.rewrite serifAst \importPath -> {
        importPath
        % .split ["/"]
        % concat [serifDirname]
        % path.join
        % \filename -> .get [filename] tree
        % (.exportedNames)
      };
      serifAst'' = serif.changeExtensions serifAst';
      esAst = serif.esModuleFromSerifModule serifAst'';
      esSource = generate (esAst, {});
      esBasename = path.basename serifFilename ".serif" + ".js";
      esFilename = path.join [absDst, path.relative absSrc serifDirname, esBasename];
      _ <- fs.mkdir {recursive: true} $ path.dirname esFilename;
      _ <- fs.writeFile esFilename esSource;
      resolve {serifFilename, esFilename}
    }
  };

  fork (console.error)
       (\filenames -> {
          ;; List files created:
          .forEach [
            \{serifFilename, esFilename} -> {
              console.log ("• " + path.relative cwd serifFilename);
              console.log ("  ➔ " + path.relative cwd esFilename)
            },
          ] filenames
        })
       (program)
};
