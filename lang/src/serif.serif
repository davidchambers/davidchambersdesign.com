import {generate} from "astring";
import {attempt, fork, mapRej, parallel, resolve} from "fluture";

import Node from "./Node.js";
import * as fs from "./fs.serif";
import * as serif from "./index.serif";
import * as path from "./path.serif";

parse filename sourceText = {
  {serif.parse filename sourceText} |> mapRej \error -> {
    lines = {
      sourceText
      |> .split [apply ["^", "m"] RegExp]
      |> .map [\(text, index) -> {number: index + 1, text: .trimEnd [] text}]
      |> chain \line -> {
           offset = line.number - error.location.start.line;
           if offset > -5 and offset <= 0 then [line] else []
         }
    };
    renderLineNumber = .padStart [4] . String;
    `\n\x1B[1m${
      path.relative (apply [] process.cwd) error.location.source
    }\x1B[0m\n\n${
      lines
      |> .map [\(line, idx, lines) -> {
           `\x1B[7m${
             renderLineNumber line.number
           }\x1B[0m${
             if idx < lines.length - 1 then line.text else {
               `${
                 .slice [0, error.location.start.column - 1] line.text
               }\x1B[7m${
                 .charAt [error.location.start.column - 1] line.text
               }\x1B[0m${
                 .slice [error.location.start.column] line.text
               }`
             }
           }\n`
         }]
      |> .join [""]
    }${
      lines
      |> .at [-1]
      |> (.number)
      |> renderLineNumber
      |> (.length)
      |> \length -> .repeat [length + error.location.start.column - 1] " "
    }^\n${
      error.message
    }\n`
  }
};

reducer futureTree filename = {
  futureTree >>= findDependencies filename
};

findDependencies filename tree = {
  if .has [filename] tree then resolve tree else do {
    sourceText <- mapRej (.message) $ fs.readFile filename;
    ast <- parse filename sourceText;
    dependencies = ast.imports >>= \{source: {value}} -> {
      if .test [value] (RegExp "^[./].*[.]serif$") then {
        [path.join [filename, "..", value]]
      } else {
        []
      }
    };
    exportedNames = ast.exports >>= match Node (const []) {ExportNamedDeclaration: map ((.name) . (.exported))};
    reduce reducer
           (resolve $ construct Map [[...tree, [filename, {sourceText, ast, dependencies, exportedNames}]]])
           dependencies
  }
};

orderDependencies tree = {
  recur unsorted! sorted! = {
    if unsorted!.length is 0 then sorted! else {
      filename = .shift [] unsorted!;
      {dependencies} = .get [filename] tree;
      if .every [\filename -> .has [filename] sorted!] dependencies then {
        .add [filename] sorted!
      } else {
        .push [filename] unsorted!
      };
      recur unsorted! sorted!
    }
  };
  Array.from $ recur (Array.from $ .keys [] tree) $ construct Set [[]]
};

{
  cwd = apply [] process.cwd;
  [,, src, lib, ...filenames] = process.argv;
  program = do {
    tree <- reduce reducer (resolve $ construct Map [[]]) filenames;
    filenames = orderDependencies tree;
    ;; Create JavaScript module for each Serif module:
    parallel 16 $ flip map filenames \serifFilename -> do {
      serifDirname = path.dirname serifFilename;
      serifAst = (.ast) $ .get [serifFilename] tree;
      serifAst' <- serif.rewrite serifAst \importPath -> {
        importPath
        |> .split ["/"]
        |> concat [serifDirname]
        |> path.join
        |> \filename -> .get [filename] tree
        |> (.exportedNames)
      };
      serifAst'' = serif.changeExtensions serifAst';
      esAst = serif.esModuleFromSerifModule serifAst'';
      esSource = apply [esAst, {}] generate;
      esDirname = path.dirname serifFilename;
      esBasename = path.basename serifFilename ".serif" + ".js";
      esFilename = path.join [lib, path.relative src esDirname, esBasename];
      _ <- fs.mkdir {recursive: true} esDirname;
      _ <- fs.writeFile esFilename esSource;
      resolve {serifFilename, esFilename}
    }
  };

  fork (console.error)
       (\filenames -> {
          ;; List files created:
          .forEach [
            \{serifFilename, esFilename} -> {
              console.log (`• ${path.relative cwd serifFilename}`);
              console.log (`  ➔ ${path.relative cwd esFilename}`)
            },
          ] filenames
        })
       (program)
};
