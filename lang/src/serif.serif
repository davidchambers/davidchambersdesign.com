import {generate} from "astring";
import {attempt, fork, mapRej, parallel, resolve} from "fluture";

import * as Map from "./Map.serif";
import * as Set from "./Set.serif";
import * as fs from "./fs.serif";
import * as serif from "./index.serif";
import * as path from "./path.serif";

parse filename sourceText = {
  {serif.parse filename sourceText} |> mapRej error => {
    lines = {
      sourceText
      |> .split [apply ["^", "m"] RegExp]
      |> .map [(text, index) => {number: index + 1, text: .trimEnd [] text}]
      |> chain $ line => {
           offset = line.number - error.location.start.line;
           if offset > -5 and offset <= 0 then [line] else []
         }
    };
    renderLineNumber = .padStart [4] . String;
    `\n\x1B[1m${
      path.relative (apply [] process.cwd) error.location.source
    }\x1B[0m\n\n${
      lines
      |> .map [(line, idx, lines) => {
           `\x1B[7m${
             renderLineNumber line.number
           }\x1B[0m${
             if idx < lines.length - 1 then line.text else {
               `${
                 .slice [0, error.location.start.column - 1] line.text
               }\x1B[7m${
                 .charAt [error.location.start.column - 1] line.text
               }\x1B[0m${
                 .slice [error.location.start.column] line.text
               }`
             }
           }\n`
         }]
      |> .join [""]
    }${
      lines
      |> .at [-1]
      |> (.number)
      |> renderLineNumber
      |> (.length)
      |> length => .repeat [length + error.location.start.column - 1] " "
    }^\n${
      error.message
    }\n`
  }
};

reducer = (futureTree, filename) => {
  futureTree >>= findDependencies filename
};

findDependencies filename tree = {
  if .has [filename] tree then resolve tree else {
    mapRej (.message) (fs.readFile filename) >>= sourceText => {
      parse filename sourceText >>= ast => {
        dependencies = ast.imports >>= {source: {value}} => {
          if .test [value] (RegExp "^[./].*[.]serif$") then {
            [path.join [filename, "..", value]]
          } else {
            []
          }
        };
        exportedNames = ast.exports >>= exportDeclaration => {
          if exportDeclaration.type is "ExportNamedDeclaration" then {
            (.name) <$> exportDeclaration.specifiers
          } else {
            []
          }
        };
        .reduce [
          reducer,
          resolve $ Map.from [...tree, [filename, {
            sourceText: sourceText,
            ast: ast,
            dependencies: dependencies,
            exportedNames: exportedNames,
          }]],
        ] dependencies
      }
    }
  }
};

orderDependencies tree = {
  recur unsorted! sorted! = {
    if unsorted!.length is 0 then sorted! else {
      filename = .shift [] unsorted!;
      {dependencies} = .get [filename] tree;
      if .every [filename => .has [filename] sorted!] dependencies then {
        .add [filename] sorted!
      } else {
        .push [filename] unsorted!
      };
      recur unsorted! sorted!
    }
  };
  Array.from $ recur (Array.from $ .keys [] tree) $ Set.from []
};

{
  cwd = apply [] process.cwd;
  [,, src, lib, ...filenames] = process.argv;
  program = {
    .reduce [reducer, resolve $ Map.from []] filenames
    >>= tree => {
      ;; Create JavaScript module for each Serif module:
      orderDependencies tree
      |> map (serifFilename => {
           serifDirname = path.dirname serifFilename;
           serifAst = (.ast) $ .get [serifFilename] tree;
           exportedNames importPath = {
             .get [path.join $ [serifDirname] <> .split ["/"] importPath] tree
             |> (.exportedNames)
           };
           serif.trans serifAst exportedNames >>= jsAst => {
             jsSource = apply [jsAst, {}] generate;
             jsDirname = path.dirname serifFilename;
             jsBasename = path.basename serifFilename ".serif" + ".js";
             jsFilename = path.join [lib, path.relative src jsDirname, jsBasename];
             jsDirname
             |> fs.mkdir {recursive: true}
             |> chain (const_ $ fs.writeFile jsFilename jsSource)
             |> map (const_ {serifFilename: serifFilename, jsFilename: jsFilename})
           }
         })
      |> parallel 16
    }
  };

  fork (console.error)
       (filenames => {
          ;; List files created:
          .forEach [
            {serifFilename, jsFilename} => {
              console.log (`• ${path.relative cwd serifFilename}`);
              console.log (`  ➔ ${path.relative cwd jsFilename}`)
            },
          ] filenames
        })
       (program)
};
