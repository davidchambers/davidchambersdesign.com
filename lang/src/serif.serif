import {generate} from "astring";
import * as Future from "fluture";

import Node, * from "./Node.serif";
import * as fs from "./fs.serif";
import * as serif from "./index.serif";
import parallel from "./parallel.serif";
import * as path from "./path.serif";
import Prelude from "./prelude.serif";
import vars, {declared, mergeAll} from "./vars.serif";

preludeNames = construct Set [Object.keys Prelude];

parse filename sourceText = {
  {serif.parse filename sourceText} % Future.mapRej \error -> {
    lines = {
      sourceText
      % .split [RegExp ("^", "m")]
      % .map [\(text, index) -> {number: index + 1, text: .trimEnd [] text}]
      % chain \line -> {
          offset = line.number - error.location.start.line;
          if offset > -5 && offset <= 0 then [line] else []
        }
    };
    renderLineNumber = .padStart [4] . String;
    """\n\x1B[1m${
      path.relative (Deno.cwd ()) error.location.source
    }\x1B[0m\n\n${
      lines
      % .map [\(line, idx, lines) -> {
          """\x1B[7m${
            renderLineNumber line.number
          }\x1B[0m${
            if idx < lines.length - 1 then line.text else {
              """${
                .slice [0, error.location.start.column - 1] line.text
              }\x1B[7m${
                .charAt [error.location.start.column - 1] line.text
              }\x1B[0m${
                .slice [error.location.start.column] line.text
              }"""
            }
          }\n"""
        }]
      % .join [""]
    }${
      lines
      % .at [-1]
      % (.number)
      % renderLineNumber
      % (.length)
      % \length -> .repeat [length + error.location.start.column - 1] " "
    }^\n${
      error.message
    }\n"""
  }
};

createTree = reduce \futureTree filename -> {
  futureTree >>= \tree -> if tree has filename then Future.resolve tree else do {
    sourceText <- Future.mapRej (.message) $ fs.readFile filename;
    {imports, exports, statements} <- parse filename sourceText;
    dependencies = imports >>= \{source} -> {
      if .test [source.value] $ RegExp "^[./].*[.]serif$"
      then [path.join [filename, "..", source.value]]
      else []
    };
    exports = (<$> exports) $ Node.matchOr id {
      ExportNamedDeclaration: ExportNamedDeclaration . chain (Node.matchOr Array.of {
        ExportAllSpecifier: \hiding -> {
          statements
          % map vars
          % mergeAll
          % declared
          % subtract (construct Set [(.name) <$> hiding])
          % Array.from  ;; TODO: sort
          % map (join ExportSpecifier . Identifier)
        }
      })
    };
    module = Module imports exports statements;
    initial = Future.resolve $ construct Map [[...tree, [filename, {sourceText, ast: module, dependencies}]]];
    createTree initial dependencies
  }
};

orderDependencies tree = {
  unsorted! = Array.from $ .keys [] tree;
  sorted! = empty Set;
  recur = \() -> {
    if unsorted! == [] then sorted! else {
      filename = .shift [] unsorted!;
      if .every [\filename -> sorted! has filename] $ (.dependencies) $ .get [filename] tree
      then .add [filename] sorted!
      else .push [filename] unsorted!;
      recur ()
    }
  };
  Array.from $ recur ()
};

{
  cwd = Deno.cwd ();
  [src, dst, ...filenames] = Deno.args;
  toAbs abs rel = path.join $ [abs] <> .split ["/"] rel;  ;; use / (even on Windows)
  absSrc = toAbs cwd src;
  absDst = toAbs cwd dst;
  absFilenames = toAbs absSrc <$> filenames;
  program = do {
    tree <- createTree (Future.resolve $ construct Map [[]]) absFilenames;
    filenames = orderDependencies tree;
    ;; Create JavaScript module for each Serif module:
    parallel $ flip map filenames \serifFilename -> do {
      serifDirname = path.dirname serifFilename;
      serifAst = (.ast) $ .get [serifFilename] tree;
      {imports, exports, statements} = serifAst;
      {declared, referenced} = vars serifAst;
      undeclared = referenced - declared;
      imports <- parallel $ (<$> serifAst.imports) $ Node.match {
        ImportDeclaration: \source -> {
          map (ImportDeclaration source . join) . parallel . map (Node.matchOr (Future.resolve . Array.of) {
            ImportAllSpecifier: \hiding -> do {
              namesExported <- construct Set . Array.of <$> {
                if .endsWith [".serif"] source.value then {
                  source.value
                  % .split ["/"]
                  % concat [serifDirname]
                  % path.join
                  % \filename -> .get [filename] tree
                  % (.ast)
                  % (.exports)
                  % chain (Node.matchOr (const []) {ExportNamedDeclaration: map ((.name) . (.exported))})
                  % Future.resolve
                } else {
                  Object.keys <$> Future.attemptP \() -> import source.value
                }
              };
              namesHidden = construct Set [(.name) <$> hiding];
              namesHiddenNeedlessly = namesHidden - namesExported;
              if namesHiddenNeedlessly.size > 0 then {
                Future.reject $ Error {
                  (format.list $ Array.from namesHiddenNeedlessly)
                  + " "
                  + (if namesHiddenNeedlessly.size == 1 then "is" else "are")
                  + " not exported from "
                  + source.value
                  + " so need not be hidden"
                }
              } else {
                namesExported - namesHidden & undeclared
                % Array.from  ;; TODO: sort
                % map (\name -> ImportSpecifier (Identifier name)
                                                (Identifier $ if preludeNames has name then "$" + name else name))
                % Future.resolve
              }
            }
          })
        }
      };
      serifAst = serif.changeExtensions $ serif.rewrite $ Module imports exports statements;
      esAst = serif.esModuleFromSerifModule serifAst;
      esSource = generate (esAst, {});
      esBasename = path.basename serifFilename ".serif" + ".js";
      esFilename = path.join [absDst, path.relative absSrc serifDirname, esBasename];
      _ <- fs.mkdir {recursive: true} $ path.dirname esFilename;
      _ <- fs.writeFile esFilename esSource;
      Future.resolve {serifFilename, esFilename}
    }
  };

  Future.fork (console.error)
              (\filenames -> {
                 ;; List files created:
                 .forEach [
                   \{serifFilename, esFilename} -> {
                     console.log ("• " + path.relative cwd serifFilename);
                     console.log ("  ➔ " + path.relative cwd esFilename)
                   },
                 ] filenames
               })
              (program)
};
