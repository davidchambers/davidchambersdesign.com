import List, {Nil} from "./List.serif";
import {maybe} from "./Maybe.serif";

export default \node -> {
  {declared, referenced} = vars node;
  add! set x = set.add x;
  {declared: reduce add! (empty Set) declared, referenced: reduce add! (empty Set) referenced}
};

emptyVariables = {declared: Nil, referenced: Nil};

without lhs rhs = reject (in rhs) lhs;

merge lhs rhs = {
  declared:   lhs.declared <> rhs.declared,
  referenced: lhs.referenced <> rhs.referenced,
};

mergeAll = reduce merge emptyVariables;

vars node = case node of [
  ArrayExpression properties                                  -> mergeAll (vars <$> properties),
  ArrayPattern properties                                     -> mergeAll (vars <$> properties),
  ArrowAssignmentStatement pattern expression                 -> {declared: (.referenced) $ vars pattern, referenced: Nil} `merge` vars expression,
  ArrowFunctionExpression parameters body                     -> {declared: Nil, referenced: (.referenced) (vars body) `without` (.referenced) (mergeAll $ vars <$> parameters)},
  AssignmentExpression operator left right                    -> vars left `merge` vars right,
  Block statements result                                     -> { {declared, referenced} = maybe id merge (vars <$> result) $ mergeAll (vars <$> statements); {declared: Nil, referenced: referenced `without` declared} },
  BlockStatement statements                                   -> { {declared, referenced} = mergeAll (vars <$> statements); {declared: Nil, referenced: referenced `without` declared} },
  CallExpression callee arguments                             -> vars callee `merge` mergeAll (vars <$> arguments),
  CaseClause predicate consequent                             -> vars consequent,
  CaseExpression discriminant cases                           -> vars discriminant `merge` mergeAll (vars <$> cases),
  ConditionalExpression predicate consequent alternative      -> vars predicate `merge` vars consequent `merge` maybe emptyVariables vars alternative,
  DataConstructorDefinition identifier parameters             -> vars identifier,
  DataTypeDeclaration identifier constructors implementations -> {declared: (.referenced) $ mergeAll (vars <$> constructors), referenced: Nil},
  DoBlockExpression operations result                         -> mergeAll (vars <$> operations) `merge` vars result,
  ExportDefaultDeclaration declaration                        -> vars declaration,
  ExportNamedDeclaration specifiers                           -> mergeAll $ vars <$> specifiers,
  ExportSpecifier local exported                              -> vars local,
  ExpressionStatement expression                              -> vars expression,
  ForStatement init test update body                          -> vars init `merge` vars test `merge` vars update `merge` vars body,
  FunctionDeclaration identifier parameters body              -> {declared: (.referenced) $ vars identifier, referenced: (.referenced) (vars body) `without` (.referenced) (mergeAll $ vars <$> parameters) `without` (.referenced) (vars identifier)},
  FunctionExpression parameters body                          -> {declared: Nil, referenced: (.referenced) (vars body) `without` (.referenced) (mergeAll $ vars <$> parameters)},
  GeneratorFunctionDeclaration identifier parameters body     -> {declared: (.referenced) $ vars identifier, referenced: (.referenced) (vars body) `without` (.referenced) (mergeAll $ vars <$> parameters) `without` (.referenced) (vars identifier)},
  Identifier name                                             -> {declared: Nil, referenced: pure List name},
  IfElseStatement predicate consequent alternative            -> vars predicate `merge` vars consequent `merge` vars alternative,
  IfStatement predicate consequent                            -> vars predicate `merge` vars consequent,
  ImportDeclaration source specifiers                         -> mergeAll $ vars <$> specifiers,
  ImportDefaultSpecifier local                                -> {declared: (.referenced) $ vars local, referenced: Nil},
  ImportNamespaceSpecifier local                              -> {declared: (.referenced) $ vars local, referenced: Nil},
  ImportSpecifier imported local                              -> {declared: (.referenced) $ vars local, referenced: Nil},
  InfixCallExpression operator left right                     -> vars left `merge` vars right,
  InfixExpression operator left right                         -> vars left `merge` vars right,
  LabeledStatement label body                                 -> vars body,
  LambdaCaseExpression cases                                  -> mergeAll (vars <$> cases),
  LeftSection operator operand                                -> vars operand,
  LetDeclaration pattern expression                           -> { declared = (.referenced) $ vars pattern; {declared, referenced: (.referenced) (vars expression) `without` declared} },
  MemberExpression object property                            -> vars object `merge` vars property,
  Module imports exports statements                           -> mergeAll (vars <$> imports) `merge` mergeAll (vars <$> exports) `merge` mergeAll (vars <$> statements),
  ObjectExpression properties                                 -> mergeAll $ vars <$> properties,
  ObjectPattern properties                                    -> mergeAll $ vars <$> properties,
  PrefixExpression operator operand                           -> vars operand,
  Property key value                                          -> vars key `merge` vars value,
  RestElement argument                                        -> vars argument,
  ReturnStatement argument                                    -> vars argument,
  RightSection operator operand                               -> vars operand,
  SpreadElement argument                                      -> vars argument,
  SwitchCase predicates statements                            -> mergeAll (maybe emptyVariables vars <$> predicates) `merge` mergeAll (vars <$> statements),
  SwitchStatement discriminant cases                          -> vars discriminant `merge` mergeAll (vars <$> cases),
  VariableDeclaration pattern expression                      -> { declared = (.referenced) $ vars pattern; {declared, referenced: (.referenced) (vars expression) `without` declared} },
  _                                                           -> emptyVariables,
];
