#!/usr/bin/env node

'use strict';

const fs            = require ('node:fs');
const os            = require ('node:os');
const path          = require ('node:path');
const repl          = require ('node:repl');

const escodegen     = require ('escodegen');
const Future        = require ('fluture');
const sanctuary     = require ('sanctuary');

const codegen       = require ('../codegen.js');
const grammar       = require ('../grammar.js');


const S = sanctuary.unchecked;

const B = f => g => x => f (g (x));

//    filename :: Integer -> String
const filename = now => `/tmp/serif-repl-${now}.mjs`;

//    read :: Integer -> String -> Future Error a
const read = now => S.pipe ([
  S.concat ('export default default default = '),
  S.concat (`import * from ${JSON.stringify (path.join (__dirname, '..', 'es.mjs'))} `),
  Future.encase (grammar.parse),
  S.map (codegen.toEsModule (path.join (__dirname, '..', '..'))),
  S.map (escodegen.generate),
  S.chain (code => Future.node (done => fs.writeFile (filename (now), code, {encoding: 'utf8'}, done))),
  S.chain (_ => Future.encaseP (name => import (name)) (filename (now))),
  S.map (module => module.default),
]);

const print = value => {
  switch (Object.prototype.toString.call (value)) {
    case '[object Null]':
    case '[object Undefined]':
    case '[object Boolean]':
      return `\u001B[35m${S.show (value)}\u001B[0m`;
    case '[object Number]':
      return `\u001B[33m${S.show (value)}\u001B[0m`;
    case '[object String]':
      return `\u001B[32m${S.show (value)}\u001B[0m`;
    case '[object Symbol]':
      return `\u001B[36m:${Symbol.keyFor (value)}\u001B[0m`;
    case '[object Date]':
      return `(\u001B[1mnew\u001B[0m Date ${print (Number (value))})`;
    case '[object RegExp]':
      return `(\u001B[1mnew\u001B[0m RegExp ${print (value.source)} ${print (value.flags)})`;
    case '[object Set]':
      return `(\u001B[1mnew\u001B[0m Set ${print (Array.from (value))})`;
    case '[object Map]':
      return `(\u001B[1mnew\u001B[0m Map ${print (Array.from (value))})`;
    case '[object Array]':
      return `[${S.unwords (S.map (print) (value))}]`;
    case '[object Object]':
      return `{${S.unwords (S.chain (property => [print (property), print (value[property])])
                                    (S.concat (Object.getOwnPropertySymbols (value))
                                              (Object.getOwnPropertyNames (value))))}}`;
    default:
      return `${S.show (value)}`;
  }
};

const server = repl.start ({
  prompt: '>>> ',
  eval: (code, context, filename, callback) => {
    Future.fork (err => {
                   if (err.name === 'SyntaxError') {
                     callback (new repl.Recoverable (err));
                   } else {
                     if (err.name === 'ReferenceError') {
                       err.message = err.message.replace (
                         /^_([^ ]+)/,
                         (_, encoded) => encoded.replace (
                           /[$]([0-9A-F]{4})/g,
                           (_, code) => String.fromCharCode (parseInt (code, 16))
                         )
                       );
                     }
                     console.error (err);
                     console.log ();
                     server.displayPrompt (false);
                   }
                 })
                (result => callback (null, result))
                (read (Date.now ()) (code));
  },
  writer: value => `${print (value)}\n`,
});

server.setupHistory (
  path.join (os.homedir (), '.serif-repl-history'),
  err => { if (err != null) throw err; },
);
