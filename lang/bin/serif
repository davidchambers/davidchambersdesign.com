#!/usr/bin/env node

'use strict';

const fs            = require ('node:fs');
const path          = require ('node:path');

const escodegen     = require ('escodegen');
const Future        = require ('fluture');
const S             = require ('sanctuary');

const codegen       = require ('../codegen.js');
const grammar       = require ('../grammar.js');


const I = x => x;
const K = x => y => x;
const B = f => g => x => f (g (x));
const Y = f => (g => g (g)) (g => f (x => g (g) (x)));

//    readFile :: String -> Future Error String
const readFile = filename => (
  Future.node (done => fs.readFile (filename, {encoding: 'utf8'}, done))
);

//    writeFile :: String -> String -> Future Error String
const writeFile = filename => data => (
  S.map (K (filename))
        (Future.node (done => fs.writeFile (filename, data, {encoding: 'utf8'}, done)))
);

//    mkdir :: String -> Future Error String
const mkdir = dirname => (
  S.map (K (dirname))
        (Future.node (done => fs.mkdir (dirname, {recursive: true}, done)))
);

//    parse :: String -> Future Error SerifExpr
const parse = Future.encase (grammar.parse);

//    dependencies :: StrMap (Array String) -> String -> Future Error (StrMap (Array String))
const dependencies = Y (recur => deps => filename =>
  S.maybe (S.pipe ([(x => (console.error (filename), x)),
                    readFile,
                    S.chain (parse),
                    S.map (S.mapMaybe (statement => statement.type === 'star-import'    ? S.Just (statement.source) :
                                                    statement.type === 'default-import' ? S.Just (statement.source) :
                                                    /** * ** * ** otherwise ** * ** * **/ S.Nothing)),
                    S.map (S.filter (source => source.startsWith ('/') || source.startsWith ('.'))),
                    S.map (S.map (source => path.join (filename, '..', source))),
                    S.chain (filenames => S.reduce (S.flip (filename => S.chain (deps => recur (deps) (filename))))
                                                   (Future.resolve (S.insert (filename) (filenames) (deps)))
                                                   (filenames))])
                  (filename))
          (K (Future.resolve (deps)))
          (S.value (filename) (deps))
);

//    sort :: Array String -> Array (Pair String (Array String)) -> Array String
const sort = Y (recur => filenames =>
  S.array (filenames)
          (S.pair (s => ss => pairs => S.all (S.flip (S.elem) (filenames)) (ss) ?
                                       recur (S.append (s)
                                                       (filenames))
                                             (pairs) :
                                       recur (filenames)
                                             (S.append (S.Pair (s) (ss))
                                                       (pairs))))
);

//    compile :: String -> String -> Future Error String
const compile = filename => S.pipe ([
  readFile,
  S.chain (parse),
  S.map (codegen.toEsModule (path.dirname (filename))),
  S.map (escodegen.generate),
  S.apSecond (mkdir (path.dirname (filename))),
  S.chain (writeFile (filename)),
]);

//    updatePath :: String -> String -> String -> String
const updatePath = from => to => filename => (
  path.join (to, path.relative (from, filename))
);

//    updateExtension :: String -> String -> String -> String
const updateExtension = from => to => filename => (
  path.join (path.dirname (filename),
             path.basename (filename, from) + to)
);

//    program :: String -> String -> String -> Future Error String
const program = src => lib => S.pipe ([
  dependencies ({}),
  S.map (S.pairs),
  S.map (sort ([])),
  S.chain (S.traverse (Future)
                      (S.chain (compile)
                               (B (updateExtension ('.serif') ('.mjs'))
                                  (updatePath (src) (lib))))),
  S.map (S.map (S.concat ('- '))),
  S.map (S.concat (['', 'Files generated:', ''])),
  S.map (S.unlines),
]);

Future.fork (console.error)
            (console.log)
            (program (process.argv[2])
                     (process.argv[3])
                     (process.argv[4]));
