#!/usr/bin/env node

'use strict';

const fs            = require ('node:fs');
const path          = require ('node:path');

const escodegen     = require ('escodegen');
const Future        = require ('fluture');
const S             = require ('sanctuary');

const codegen       = require ('../codegen.js');
const {B, K, Y}     = require ('../combinators.js');
const expression    = require ('../expression.js');
const grammar       = require ('../grammar.js');


//    readFile :: String -> Future Error String
const readFile = filename => (
  Future.node (done => fs.readFile (filename, {encoding: 'utf8'}, done))
);

//    writeFile :: String -> String -> Future Error String
const writeFile = filename => data => (
  S.map (K (filename))
        (Future.node (done => fs.writeFile (filename, data, {encoding: 'utf8'}, done)))
);

//    mkdir :: String -> Future Error String
const mkdir = dirname => (
  S.map (K (dirname))
        (Future.node (done => fs.mkdir (dirname, {recursive: true}, done)))
);

//    parse :: String -> Future Error SerifExpr
const parse = Future.encase (grammar.parse);

//    imports :: SerifExpr -> Array String
const imports = Y (recur => expression.fold ({
  number: K ([]),
  string: K ([]),
  symbol: K ([]),
  identifier: K ([]),
  array: S.chain (recur),
  object: S.chain (S.chain (recur)),
  and: S.on (S.concat) (recur),
  or: S.on (S.concat) (recur),
  if: predicate => consequent => alternative => S.chain (recur) ([predicate, consequent, alternative]),
  switch: discriminant => cases => S.concat (recur (discriminant)) (S.chain (c => S.concat (recur (c.predicate)) (recur (c.consequent))) (cases)),
  import: names => body => S.concat (names) (recur (body)),
  lambda: K (recur),
  invocation: K (S.chain (recur)),
  application: callee => args => (
    callee.type === 'identifier' && callee.name === 'require' && args[0].type === 'string'
    ? [args[0].value]
    : S.concat (recur (callee)) (S.chain (recur) (args))
  ),
  new: S.chain (recur),
  placeholder: [],
}));

//    dependencies :: StrMap (Array String) -> String -> Future Error (StrMap (Array String))
const dependencies = Y (recur => deps => filename =>
  S.maybe (S.pipe ([readFile,
                    S.chain (parse),
                    S.map (imports),
                    S.map (S.filter (name => name.startsWith ('/') || name.startsWith ('.'))),
                    S.map (S.map (name => path.join (filename, '..', name + '.serif'))),
                    S.chain (filenames => S.reduce (S.flip (filename => S.chain (deps => recur (deps) (filename))))
                                                   (Future.resolve (S.insert (filename) (filenames) (deps)))
                                                   (filenames))])
                  (filename))
          (K (Future.resolve (deps)))
          (S.value (filename) (deps))
);

//    sort :: Array String -> Array (Pair String (Array String)) -> Array String
const sort = Y (recur => filenames =>
  S.array (filenames)
          (S.pair (s => ss => pairs => S.all (S.flip (S.elem) (filenames)) (ss) ?
                                       recur (S.append (s)
                                                       (filenames))
                                             (pairs) :
                                       recur (filenames)
                                             (S.append (S.Pair (s) (ss))
                                                       (pairs))))
);

//    compile :: String -> String -> Future Error String
const compile = filename => S.pipe ([
  readFile,
  S.chain (parse),
  S.map (codegen.withEcmaScript),
  S.map (codegen.toJs (path.dirname (filename))),
  S.map (codegen.toCommonJsModule),
  S.map (escodegen.generate),
  S.apSecond (mkdir (path.dirname (filename))),
  S.chain (writeFile (filename)),
]);

//    updatePath :: String -> String -> String -> String
const updatePath = from => to => filename => (
  path.join (to, path.relative (from, filename))
);

//    updateExtension :: String -> String -> String -> String
const updateExtension = from => to => filename => (
  path.join (path.dirname (filename),
             path.basename (filename, from) + to)
);

//    program :: String -> String -> String -> Future Error String
const program = src => lib => S.pipe ([
  dependencies ({}),
  S.map (S.pairs),
  S.map (sort ([])),
  S.chain (S.traverse (Future)
                      (S.chain (compile)
                               (B (updateExtension ('.serif') ('.js'))
                                  (updatePath (src) (lib))))),
  S.map (S.map (S.concat ('- '))),
  S.map (S.concat (['', 'Files generated:', ''])),
  S.map (S.unlines),
]);

Future.fork (console.error)
            (console.log)
            (program (process.argv[2])
                     (process.argv[3])
                     (process.argv[4]));
